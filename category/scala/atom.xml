<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scala | I Will Survive]]></title>
  <link href="http://ReSTARTR.github.io/category/scala/atom.xml" rel="self"/>
  <link href="http://ReSTARTR.github.io/"/>
  <updated>2014-06-14T15:42:13+09:00</updated>
  <id>http://ReSTARTR.github.io/</id>
  <author>
    <name><![CDATA[ReSTARTR]]></name>
    <email><![CDATA[yoshida.masaki+restartr@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[EventStatsはherokuとMongoLabとさくらVPSで動いている]]></title>
    <link href="http://ReSTARTR.github.io/2011/12/28/eventstats-consist-of-heroku-mongolab-and-sakura-vps/"/>
    <updated>2011-12-28T21:27:52+09:00</updated>
    <id>http://ReSTARTR.github.io/2011/12/28/eventstats-consist-of-heroku-mongolab-and-sakura-vps</id>
    <content type="html"><![CDATA[<p>今月頭に<a href="/2011/12/10/eventststs">ブログ書きました</a>が、EventStatsという勉強会の参加者の推移が見れるサービスを公開しました。</p>

<ul>
  <li><a href="http://eventstats.restartr.com">EventStats - イベントの統計情報が見れます</a></li>
</ul>

<p>まぁ自分が欲しかっただけなんですけど、使ってみて頂ければ幸いです。
今回はそのサービスの構成とかについて書いてみます。</p>

<h3 id="section">アジェンダ</h3>

<ol>
  <li>全体像</li>
  <li>システム構成</li>
  <li>Gitリポジトリ</li>
  <li>MongoDBのPaaS</li>
  <li>各イベント管理サービスAPIの違い</li>
  <li>開発メモ</li>
</ol>

<h3 id="section-1">1.全体像</h3>

<p>開発環境も含めて全体像を図にしてみました。(初Cacooですが超べんりですね！)</p>

<p>赤い線がGit操作で、黒い点線がMongoDBへのアクセスです。</p>

<p><a href="https://cacoo.com/diagrams/Cp2yo6tQNlxCm5av"><img border="1" alt="全体像" src="https://cacoo.com/diagrams/Cp2yo6tQNlxCm5av-2260A.png" /></a></p>

<h3 id="section-2">2.システム構成</h3>

<p>大きく分けてwebとクローラーの２つです。
webはherokuに、クローラーはさくらのVPSに配置。</p>

<p>まずは優先してデータ蓄積を…ということでクローラーをpythonとmongodbで作成しました。
(サービス的にはやいとこデータためないと意味ないので。)</p>

<p>クローラーは５分おきに起動するのでScalaよりPythonを選択しました。起動コスト重視です。
(Scalaでサクサク開発できる程のスキルではないというのもありますが… )</p>

<p>実行場所はherokuのworkerも考えたましたが、最終的に既に利用していたさくらVPSでcronジョブとして運用することに。</p>

<p>ということでScalaのWebはデータ参照のみで、データの更新はしません。</p>

<h3 id="git">3.Gitリポジトリ</h3>

<p>webとクローラーは分けてGitで管理。リモートリポジトリはどちらもさくらのVPS上においています。
ただし、本番リリースは開発PCからherokuに別途pushします。</p>

<p>※webもさくらVPSにリモートリポジトリを持って、本番データを参照するステージング環境として利用しています。</p>

<h4 id="eventstats-web">eventstats-web</h4>

<ul>
  <li>host: <a href="http://www.heroku.com/">heroku</a> (Chedar)</li>
  <li>scala
    <ul>
      <li>フレームワーク: <a href="https://github.com/unfiltered/unfiltered">unfiltered</a> 0.5.1</li>
      <li>mongodb接続: <a href="http://api.mongodb.org/scala/casbah/2.1.5.0/">casbah</a> 2.1.5-1</li>
      <li>テンプレートエンジン: <a href="https://github.com/unfiltered/unfiltered/tree/master/scalate">unfiltered-scalate</a> (ssp)</li>
      <li>テスティングライブラリ: <a href="https://github.com/unfiltered/unfiltered/tree/master/spec">unfiltered-specs</a></li>
    </ul>
  </li>
  <li>チャートのレンダリング: <a href="http://code.google.com/apis/chart/index.html">Google Chart Tools</a></li>
</ul>

<h4 id="eventstats-crawler">eventstats-crawler</h4>

<ul>
  <li>host: さくらのvps</li>
  <li>python 2.6
    <ul>
      <li>フレームワーク: なし</li>
      <li>mongodb接続: <a href="http://api.mongodb.org/python/1.11/">pymongo</a> 1.11</li>
      <li>テスティングライブラリ: <a href="http://readthedocs.org/docs/nose/en/latest/">nose</a></li>
      <li>その他: <a href="http://www.crummy.com/software/BeautifulSoup/">BeautifulSoup</a> (<em>partake.inのwebスクレイピングに利用</em>)</li>
    </ul>
  </li>
</ul>

<h3 id="mongodbpaas">4.MongoDBのPaas</h3>

<p>herokuプラグインとして<a href="https://addons.heroku.com/mongolab">MongoLab</a>と<a href="https://addons.heroku.com/mongohq">MongoHQ</a>の２つが提供されています。どちらも無料枠があるのですが、MongoLabの方が無料で利用できる容量が大きいのでこちらを選択。</p>

<p>月額の利用料金は以下です。（括弧内は1MBあたりの金額の目安です）
<em>これ以上の容量も利用可能ですが個人で払う範囲ではないと思い除外してます。</em></p>

<h4 id="mongolab">MongoLab</h4>
<ul>
  <li>$ 0.00/240MB</li>
  <li>$10.00/0.5GB  ($0.020/MB)</li>
  <li>$20.00/2.0GB  ($0.009/MB)</li>
</ul>

<h4 id="mongohq">MongoHQ</h4>

<ul>
  <li>$ 0.00/ 16MB</li>
  <li>$ 5.00/256MB  ($0.019/MB)</li>
  <li>$15.00/2.0GB  ($0.007/MB)</li>
</ul>

<h3 id="api">5.各イベント管理サービスAPIの違い</h3>

<p>まずは<strong>atnd, zusaar, partake.inの３サービスに対応</strong>。</p>

<p>それぞれ検索APIを提供してくれているのですが、当然ながら規格とかもないのでリクエストもレスポンスも違いがあります。</p>

<p>データ蓄積する際にそのAPIの差異を吸収して、webアプリから参照する際は気にしなくていい戦略をとりました。
APIの違い検索のみに特化して違いをまとめると以下の通りです。</p>

<h4 id="atnd">atnd</h4>

<p>イベント数も多いので、このAPIをスタンダードに設定。
* API仕様
 * <a href="http://api.atnd.org/">http://api.atnd.org/</a>
* リクエストパス
 * <a href="http://api.atnd.org/events/">/events/</a>
   * イベントの検索
 * <a href="http://api.atnd.org/events/users/">/events/users/</a>
   * イベントに参加しているユーザーの検索</p>

<h4 id="zusaar">zusaar</h4>

<p>基本的にはatnd準拠っぽい感じだけど細かい違いがあります。
 * API仕様
   * <a href="http://www.zusaar.com/doc/api.html">http://www.zusaar.com/doc/api.html</a>
 * リクエストパス
   * <a href="http://www.zusaar.com/api/event/">/api/event/</a>
     * イベントの検索
   * <a href="http://www.zusaar.com/api/event/user/">/api/event/user/</a>
     * イベントに参加しているユーザーの検索
atndとの違い
 * エントリポイントやデータのキー名が単数形
   * events→event
   * users→user
 * 明確なフィールドとしてのtwitter_idが無い
    * 管理者も参加ユーザーも
 * ハッシュタグがない
 * レスポンスはjson一択</p>

<h4 id="partakein">partake.in</h4>

<p>全然違うAPI。APIリストにあっても未実装がほとんどなので、利用する際はソースを確認したほうが良いです。
今回必要になりそうなAPIは２つくらいでした。</p>

<ul>
  <li>API仕様
    <ul>
      <li><a href="http://code.google.com/p/partakein/wiki/PublicWebAPI">http://code.google.com/p/partakein/wiki/PublicWebAPI</a></li>
    </ul>
  </li>
  <li>リクエストパス
    <ul>
      <li><a href="http://partake.in/api/event/search/">/api/event/search</a>
        <ul>
          <li>イベントの検索</li>
        </ul>
      </li>
      <li><a href="http://partake.in/api/event/get/">/api/event/get</a>
        <ul>
          <li>イベントの詳細データ取得</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>APIのソース(抜粋)
    <ul>
      <li><a href="http://code.google.com/p/partakein/source/browse/trunk/Partake/src/main/java/in/partake/controller/api/event/SearchAction.java">in.partake.controller.api.event.SearchAction.java</a></li>
      <li><a href="http://code.google.com/p/partakein/source/browse/trunk/Partake/src/main/java/in/partake/controller/api/event/EventAction.java">in.partake.controller.api.event.EventAction.java</a></li>
    </ul>
  </li>
</ul>

<p>その他の特徴は以下。</p>

<ul>
  <li>複数イベントを特定して一括取得するAPIはない</li>
  <li>フィールド名がcamelCase形式</li>
  <li>レスポンスはjson一択</li>
  <li>検索パラメータも特殊かつ少数</li>
  <li>検索APIで取得できるのはイベントの固定情報のみ
    <ul>
      <li>参加枠数はAPIから取得可能</li>
      <li>変動するユーザー数は取得不可能</li>
      <li>→Webページをスクレイピングするしかないという結論</li>
    </ul>
  </li>
</ul>

<p>上記をふまえ、atnd/zusaarはJSON形式でAPIからデータ取得。</p>

<p>partake.inのみイベントのリストをAPIから取得して、ユーザー数はWebページのスクレイピングで対応しました。</p>

<h3 id="section-3">6.開発メモ</h3>

<h4 id="webherokuvps">web(heroku)からもクローラー(さくらのvps)からも離れた場所にある</h4>

<p>開発PC上だと気にならなかったのですが、1件1件findしてinsertやupdateをしていると当然遅いです。なのである程度まとめて一気にinsertする方針に変更しました(ベンチ結果はありません ^^;)。
更新はクローラーの１プロセスからのみ実行されるので、トランザクションとか意識しなくて良いです。なので比較的自由な構成がとれます。</p>

<h4 id="scalajson-api">ScalaでJSON API</h4>

<p>まずはUnfilteredでJSON APIを作成。けど、jsでjson取得〜チャート生成の実行時間が思いの外大きいので、jsonも１枚のHTMLに埋め込む方針に変更。</p>

<h3 id="section-4">さいごに</h3>

<p>ざっと書きだすとこんな感じです。まぁこんな構成もあるよ、ってくらいにしか言えませんが。</p>

<p>webとクローラーを分けたことで、開発中のスキーマ変更が柔軟に行えたのは良かったのですが、スキーマ定義を共通で管理していないので、そのあたりうまく管理できると良いなと思ったり。
当初はもう少しwebの機能も多かったのですが、効率化をしているうちにシンプルな形に落ち着きました。Scalaのコードもかなり小規模なものになっています。
イベント管理者の方からのご意見ご要望などいただけると嬉しいです :)</p>

<ul>
  <li><a href="http://eventstats.restartr.com">EventStats - イベントの統計情報が見れます</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第二回 #Playframework 勉強会 in Tokyo #play_ja に行ってきた]]></title>
    <link href="http://ReSTARTR.github.io/2011/10/10/play-framework-study-in-tokyo/"/>
    <updated>2011-10-10T15:59:13+09:00</updated>
    <id>http://ReSTARTR.github.io/2011/10/10/play-framework-study-in-tokyo</id>
    <content type="html"><![CDATA[<ul>
  <li><a href="http://atnd.org/events/19107">第二回 #Playframework 勉強会 in Tokyo #play_ja</a></li>
</ul>

<p><a href="http://atnd.org/events/17724">第一回</a>は大阪開催だったのとそもそも開催を知らなくて参加できませんでしたが、第二回は有難いことに休日に東京で開催されたので行ってきました。運営の皆様、参加者の皆様、懇親会でお話させて頂いた皆様、どうも有難うございました。</p>

<h3 id="section">勉強会のまとめ記事</h3>

<p>下記ブログにありますのでそちらをどうぞ。</p>

<ul>
  <li><a href="http://d.hatena.ne.jp/ikeike443/20111009/p1">第二回 Playframework 勉強会 in Tokyo やりました #play_ja - 複雑系スパゲティソース(はてな版)</a></li>
  <li>まとめ記事へのリンクが最後にあります。</li>
  <li><a href="http://ponta027.blogspot.com/2011/10/playframework.html">Playframework勉強会#2まとめ（スライド）</a></li>
  <li>発表資料をまとめてあります。</li>
</ul>

<p>なのでここでは、全体的な話しではなく関心の強いところに関してのみ書こうと思います。</p>

<p>ただの感想文です。</p>

<h3 id="play">Play!の今とこれから</h3>

<p>Play!がどのような分野で使われ、どのように変化していくのかが今の大きな関心事であり、今回の参加理由でした。</p>

<p>今回の発表を聞いていると、Java界隈の救世主（候補）的な位置づけとして期待されているという段階なのでしょう。</p>

<p>主催者の@<a href="https://twitter.com/ikeike443">ikeike443</a>さんの会社のシャノンさんでは実際業務でPlay!を使われていたり、@<a href="https://twitter.com/genki_">genki_</a>さんは今まさに<a href="http://harp.ruru.ne.jp/sol/play/play2.pdf">SI案件で業務アプリケーションにPlay!を導入しようとしている</a>ところだそうで。</p>

<h3 id="play2x">Play!2.x系による変化</h3>

<p>ただ、Play!が今後2.x系でScalaベースでの開発に切り替わるので、それによって今の勢いがどう変わっていくのでしょうか。JavaベースのPlay!1.xにScalaユーザーを引き込むのと、ScalaベースのPlay!2.xにJavaユーザーを引きこむのでは、大きく状況が変わってくると思います。自分はScalaユーザーなのでこの動きは非常に嬉しいですが、もしかしたら勢いが減速してしまうのではとちょっと不安になったり。</p>

<p>（プラグインのサポートがどちらか一方の言語に限定されていて、結局導入を見送るなんてこともあると思います。）</p>

<h3 id="play-1">Play!の外部環境</h3>

<p>とはいえ、外部環境としてはPlay!のサポートPassSがちょくちょく出てきているので当分は勢いが衰えることはないと思います。単体でサーバーとして動作させることが可能なだけでなく、war化も可能なのでTomcatやJettyに載っけることができる環境なら動かせてしまいます。とくに@<a href="http://twitter.com/hagikuratakeshi">hagikuratakeshi</a>さんや@<a href="https://twitter.com/mitsuhiro">mitsuhiro</a>さんが取り上げていたようにHerokuのPlay!サポートによって趣味プログラミングとして手を出しやすくなってますし。</p>

<h3 id="scalaplay">ScalaのフレームワークとしてのPlay!</h3>

<p>Scala界隈ではUnfilteredやBlueEyesのような積極的にScalaの機能を利用したFWが注目されています。（少なくとも私のTwitterのTL上では…)ただし、日本語ベースのScalaのフレームワークのリファレンスや関連記事はまだまだ少ないのが現状です。</p>

<p>Play!の場合は翻訳も積極的に行われていますし、勉強会に100人近く参加するような日本のPlay!コミュニティの存在は正直無視できないと思います。今後のPlay!界隈の動向に注目です。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scalaで設定ファイルを使いたい時どうしたらいいの？]]></title>
    <link href="http://ReSTARTR.github.io/2011/08/30/config-libraries-in-scala/"/>
    <updated>2011-08-30T00:02:15+09:00</updated>
    <id>http://ReSTARTR.github.io/2011/08/30/config-libraries-in-scala</id>
    <content type="html"><![CDATA[<p><em style="color:red">2011.08.31 kmizushimaさんから頂いた<a href="http://blog.restartr.com/2011/08/30/config-libraries-in-scala/?preview=true&amp;preview_id=1049&amp;preview_nonce=ad0bbeeef6#comment-108">コメント</a>を元に、下記の記述を修正＆追記しました。</em></p>

<ul>
  <li>Twitterのutil-evalの一時ファイル生成について</li>
  <li>AkkaのConfigファイルのパース手法について
&lt;/em&gt;</li>
</ul>

<p>TwitterのOAuthの鍵やDB接続情報など、アプリを書く上で環境によって切り替える設定が大抵の場合あると思います。普段使っているPHPの場合、設定を外部ファイルに書きだす場合、ini,yaml,xml,phpのいずれかを使うことが多いのですが、Scalaの場合、設定ファイルってどうするのか気になりました。</p>

<p>ということで、適当に思いついたライブラリやフレームワークがどのように対応しているのか調査。</p>

<h2 id="section">ライブラリ</h2>

<h3 id="properties">propertiesファイル</h3>

<ul>
  <li>javaの古くから使われている</li>
  <li>キーと値のみ設定可能</li>
  <li>依存関係がないので手軽。</li>
  <li>すべてが文字列</li>
  <li>例えばこんな感じ</li>
</ul>

<p>path/to/conf.properties</p>

<p><code>scala
hoge = "moge"
</code></p>

<p><code>scala
val p = new java.util.Properties()
val config = p.load(new java.io.FileInputStream("path/to/conf.properties");
config.get("hoge") // "moge"
</code></p>

<h3 id="twitterconfiggy">twitterのconfiggy</h3>

<ul>
  <li><a href="https://github.com/robey/configgy">https://github.com/robey/configgy</a></li>
  <li>独自フォーマット</li>
  <li>オワコン</li>
</ul>

<h3 id="twitterutil-eval">twitterのutil-eval</h3>

<ul>
  <li><a href="http://twitter.github.com/util/">http://twitter.github.com/util/</a></li>
  <li>Evalした値をそのまま利用</li>
  <li>Scalaのコンパイラに任せられる。つまりScalaコードがそのまま設定ファイルに。</li>
  <li>型安全</li>
  <li>詳しいことはこちらを参照
    <ul>
      <li><a href="http://d.hatena.ne.jp/xuwei/20110805/1312551980">twitter が Scala 大好きすぎて (?) 設定ファイルまで Scala のソースコードな件 - scalaとか・・・</a></li>
      <li><a href="http://blog.youhei.jp/scala-util-eval">Scala アプリケーションのコンフィグレーションに Twitter 製の util-eval を使ってみた - blog.youhei.jp</a></li>
    </ul>
  </li>
  <li>下記処理にて設定クラスインスタンスをapply経由で取り出せる
    <ul>
      <li><a href="https://github.com/twitter/util/blob/master/util-eval/src/main/scala/com/twitter/util/Eval.scala#L247">com.twitter.util.Eval#L247</a></li>
    </ul>
  </li>
  <li><del>一時的にjarファイルを生成するので環境に制約あるとダメ（たぶん）</del>
    <ul>
      <li>一時ファイルを生成するのは、ローカルにcloneした古いままのバージョン（1.2.5）で動作確認していたためでした。</li>
      <li>古いコード: <a href="https://github.com/twitter/util/blob/7c81842286f30aee4b2176bceb8c79ded710c88e/src/main/scala/com/twitter/util/Evaluator.scala">com.twitter.util.Evaluator</a>のコメントに<a href="https://github.com/twitter/util/blob/7c81842286f30aee4b2176bceb8c79ded710c88e/src/main/scala/com/twitter/util/Evaluator.scala#L57">All generated .scala and .class files are stored, by default, in System.getProperty(“java.io.tmpdir”)</a>と書いてあったので、「一時ファイルが生成される」と認識し、実際の動作確認でもその一時ファイルが確認できていました。</li>
      <li>しかし、新しいコード: <a href="https://github.com/twitter/util/blob/master/util-eval/src/main/scala/com/twitter/util/Eval.scala">com.twitter.util.Eval</a>のコメントには<a href="https://github.com/twitter/util/blob/master/util-eval/src/main/scala/com/twitter/util/Eval.scala#L50">If target is None, the results are compiled to memory (and are therefore ephemeral)</a>とある通り、パス指定がない場合はメモリ上の仮想ディレクトリに対して操作を行う模様です。</li>
    </ul>
  </li>
  <li>使い方</li>
</ul>

<p>設定のtraitを定義</p>

<p>src/main/scala/com/restartr/utilSample/MyConfig.scala</p>

<p>```scala
package com.restartr.utilSample</p>

<p>trait MyConfig {
  val num: Int
  val str: String
}</p>

<p>```</p>

<p>実際の設定ファイルでは、設定のTraitを継承してインスタンス生成</p>

<p>※クラスインスタンスでなくても文字列やリストでもOK。</p>

<p>path/to/config/MyConfig.scala</p>

<p><code>scala
import com.restartr.utilSample.MyConfig
new MyConfig {
  val num = 1
  val str = "san"
}
</code></p>

<p>使いたい場所でEval。</p>

<p><code>scala
val conf = Eval[MyConfig](new java.io.File("path/to/config/MyConfig.scala"))
conf.num // 1
conf.str // "san"
</code></p>

<h3 id="configrity">configrity</h3>

<ul>
  <li><a href="https://github.com/paradigmatic/Configrity">https://github.com/paradigmatic/Configrity</a></li>
  <li>akkaのフォーマットと同等
    <ul>
      <li><a href="https://github.com/paradigmatic/Configrity/wiki/Formats">設定のフォーマット</a></li>
      <li>Scala 2.9以上対象。</li>
      <li>configファイルの<strong>読み書き</strong>ができる
        <ul>
          <li>immutable, thread safe, allow functional design pattern</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="section-1">各種フレームワーク</h2>

<p>以下のフレームワークはすべて独自実装でした。Propertiesじゃ役不足だし、かといってデファクトな設定用ライブラリがないからなのでしょうか。</p>

<h3 id="akkaconfig">akkaのconfig</h3>

<ul>
  <li>akka.confとかがそれ。</li>
  <li>独自パーサーを使用
    <ul>
      <li>70行程度のシンプルなパーサー</li>
      <li><a href="https://github.com/jboner/akka/blob/master/akka-actor/src/main/scala/akka/config/ConfigParser.scala">akka.config.ConfigParser</a></li>
      <li><del>正規表現で定義されてる</del>Scalaのパーザコンビネータ(RegexParsersを継承)で定義されている</li>
      <li>”{“と”}”で階層構造を表現</li>
    </ul>
  </li>
</ul>

<p><code>scala
akka {
  cluster{
    name = "test-cluster"
  }
}
</code></p>

<ul>
  <li>使える型</li>
  <li>数値</li>
  <li>文字列</li>
  <li>真偽値（on/off , true/false)</li>
  <li>リスト [1,2,3] / [“hoge”,”moge”]</li>
</ul>

<h3 id="playframeworkconfig">play!frameworkのconfig</h3>

<ul>
  <li>独自パーサー
    <ul>
      <li><a href="https://github.com/playframework/play/blob/master/framework/src/play/utils/OrderSafeProperties.java">play.utils.OrderSafeProperties</a></li>
    </ul>
  </li>
  <li>java.util.propertiesを継承したもの。</li>
  <li>環境ごとにIDを割り当てられる
    <ul>
      <li>http://playdocja.appspot.com/documentation/1.2.1/production</li>
      <li>http://playdocja.appspot.com/documentation/1.2.1/guide11</li>
      <li>IDごとに%{ID}を頭につければ切り替えてくれるみたい</li>
    </ul>
  </li>
</ul>

<h3 id="lift">Lift</h3>

<ul>
  <li>LiftRulesが設定をもつ
    <ul>
      <li><a href="http://simply.liftweb.net/index-3.1.html#toc-Subsection-3.1.2">http://simply.liftweb.net/index-3.1.html#toc-Subsection-3.1.2</a></li>
      <li>実装はここ
*<a href="https://github.com/lift/framework/blob/master/web/webkit/src/main/scala/net/liftweb/http/LiftRules.scala">net.liftweb.http.LiftRules</a></li>
      <li>たぶんこのへん
        <ul>
          <li><a href="https://github.com/lift/framework/blob/master/core/util/src/main/scala/net/liftweb/util/Props.scala">net.liftweb.util.Props</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>ざっと調べて使ってみたところ、手軽にやるならProperties、フレームワークを使うならそれに則り、厳密にやるならTwitterのEvalや、設定ファイルを読み書きできる独特なConfigrityなんかがよさそうです。</p>

<p>XMLは…まぁないでしょうね。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ScalaのORMapperのSquerylを試してみてハマった３つのこと]]></title>
    <link href="http://ReSTARTR.github.io/2011/08/16/3-things-that-i-was-in-trouble-using-squeryl/"/>
    <updated>2011-08-16T08:00:15+09:00</updated>
    <id>http://ReSTARTR.github.io/2011/08/16/3-things-that-i-was-in-trouble-using-squeryl</id>
    <content type="html"><![CDATA[<p>ScalaのORMとしてSquerylってのがあります。</p>

<ul>
<li><a href="http://squeryl.org/index.html">Squeryl - A Scala ORM for SQL Databases</a></li>
</ul>
<p>使い方は上記リンク先を見ればだいたいわかります。</p>

<p>あと、<a href="http://twitter.com/jugyo">@jugyo</a>さんのブログに導入あたりはまとまっていますし、つまづいたらGoogleGroupで検索すれば何か見つかるかもしれません。</p>

<ul>
<li><a href="http://blog.twiwt.org/e/f34763"> Twiwt:Blog / jugyo : squeryl を試す </a></li>
<li><a href="http://blog.twiwt.org/e/7e40ce">Twiwt:Blog / jugyo : Squeryl の使い方 - セットアップ, モデルの定義, テーブル作成</a></li>
<li><a href="https://groups.google.com/group/squeryl/about"> Squeryl | Google Groups </a></li>
</ul>
<p>さて、今回はTwitterっぽいものを想定して機能を試してみたのですが、３つほどハマったところを記しておきます。</p>

<p>環境はScala2.9.0.1、Sbt0.7.7、MySQL5.5、Squeryl0.9.4です。</p>

<p>ソースはgistに登録。それを本文末尾にも掲載しておきました。</p>

<h3>１．プライマリーキーの指定での嵌りどころ</h3>
<p>1つのカラムがPKとなるテーブルスキーマの場合、org.squeryl.KeyedEntity[T]を継承して使います。</p>

<p>```scala</p>

<p>class Users(id: Long, text: String) extends KeyedEntity[Long]</p>

<p>```</p>

<p>KeyedEntityにはidというフィールドが用意されていて、継承時に型を指定することで、PKの型に適用させることができます。今回の場合であればLong型のPK「id」ということになります。</p>

<p>ただし、この場合、PKはautoincrementedになってしまいます。</p>

<p>コード的には下記のようにKeyedEntity[T]を使わずSchema継承時に定義するのと同等になるわけです。</p>

<p>```scala</p>

<p>class Users(id: Long, text: String)</p>

<p>class Db extends Schema {</p>

<p>val users = table<a href="&quot;users&quot;">User</a></p>

<p>on(users)(u =&gt; declare(</p>

<pre><code>u.id is (primaryKey, autoincremented))
</code></pre>

<p>}</p>

<p>```</p>

<p>これは結構困ります。そんな場合はSchemaを継承するときに定義を上書きすればOK。</p>

<p>```scala</p>

<p>class Users(id: Long, text: String) extends KeyedEntity[Long]</p>

<p>class Db extends Schema {</p>

<p>val users = table<a href="&quot;users&quot;">User</a></p>

<p>on(users)(u =&gt; declare(</p>

<pre><code>u.id is (primaryKey))
</code></pre>

<p>}</p>

<p>```</p>

<p>これはSquerylのGoogleGroupに書いてました。</p>

<ul>
<li><a href="https://groups.google.com/forum/#!topic/squeryl/BTrKBwikMqs">how to cancel "autoincremented" from KeyedEntity[T]</a></li>
</ul>
<h3>２．DDLのカラムの順番の嵌りどころ</h3>
<p>Db.printDdlを実行した時にカラムの順番が予測できません。</p>

<p>PKが最初にくるのかと思えばそうでもないみたい。ここは細かく追ってないですが、これもGoogleGroupに答えがありました。</p>

<ul>
<li><a href="https://groups.google.com/forum/#!topic/squeryl/ZwiDf5Q-IUI">CREATE TABLE columns in order of constructor arguments</a></li>
</ul>
<p>答えとしては、org.squeryl.internals.DatabaseAdapter:: writeCreateTableあたりをorverrideしてなんとかしてくれとのこと。</p>

<p><a href="https://github.com/max-l/Squeryl/blob/master/src/main/scala/org/squeryl/internals/DatabaseAdapter.scala#L255">https://github.com/max-l/Squeryl/blob/master/src/main/scala/org/squeryl/internals/DatabaseAdapter.scala#L255</a></p>

<p>なんか良い方法はないの…</p>

<p>とりあえず、printDdlした結果をコピーして、順番だけ書き換えて、手動で直接DBにクエリ発行すればなんとかなるでしょう。</p>

<h3>３．外部キーの利用でのはまりどころ</h3>
<p>２つのテーブルにRelationを設定してからDb.createした際、外部キーが設定されない問題がありました。</p>

<p>MySQLは5.5を使っているので外部キーに対応していない訳でもないです。</p>

<p>問題はAdapterの選定にありました。</p>

<p>org.squeryl.adapter.MySQLAdapter</p>

<p>をつかっていたのですが、</p>

<p>org.squeryl.adapter.MySQLInnoDBAdapter</p>

<p>を使えばOKでした。</p>

<p>根本の原因は、org.squeryl.adapter.MySQLAdapterに</p>

<p>```scala</p>

<p>override def supportsForeignKeyConstraints = false</p>

<p>```</p>

<p>と定義してあり、一方のorg.squeryl.adapter.MySQLInnoDBAdapterには</p>

<p>```scala</p>

<p>override def supportsForeignKeyConstraints = true</p>

<p>```</p>

<p>と定義してあります。</p>

<p>この値がtrueになっていないとForeignKeyの制約がDDLに含まれなくなってしまうので注意です。</p>

<p><a href="https://github.com/max-l/Squeryl/blob/master/src/main/scala/org/squeryl/adapters/MySQLAdapter.scala#L75">Docコメントにも書いてある</a>ので注意です。</p>

<p>以上、Squerylを弄ってみて嵌ったことをまとめてみました。</p>

<h3>Squerylの使用感</h3>
<p>ちょっと前にTwitterのStreamAPIのデータをMySQLに格納するためにSquerylを使ったのと今回少し弄ってみただけなのでまだまだ知らないことだらけです。他にも機能的はたくさん用意されていると思いますし、APIも割となじみやすいので複雑すぎないテーブル定義の場合には積極的にSquerylを使っていこうと思います。</p>

<p><em>※ドキュメントや本体のソースを追いかけたりしながら使い方を学ぶのは非常に楽しいです:)</em></p>

<p>で、ソースは以下です。</p>

<script src="https://gist.github.com/1146854.js"> </script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DotCloudのMongoDBをScalaから使ってみる]]></title>
    <link href="http://ReSTARTR.github.io/2011/05/28/access-from-scala-to-mongodb-on-dotcloud/"/>
    <updated>2011-05-28T20:00:57+09:00</updated>
    <id>http://ReSTARTR.github.io/2011/05/28/access-from-scala-to-mongodb-on-dotcloud</id>
    <content type="html"><![CDATA[<p>DotCloudにDuoStackが<a href="http://gigaom.com/cloud/exclusive-paas-startups-unite-dotcloud-buys-duostack/">買収され</a>て、DotCloudでもMongoDBが使えるようになりましたし、node.jsも使えるしで、ますますDotCloudが魅力的なものになってきました。</p>

<p>ただし、node.jsはサポートされても、WebSocketは正式サポートされていないと<a href="http://docs.dotcloud.com/components/nodejs/">公式マニュアル</a>にも書いてありますがWebSocketサポート済みのDuoStack買収によってどう流れるか気になるところです。</p>

<p>さて今回は、前回作ったものをベースにScalaからMongoDBへアクセスするサンプルをDotCloudで動かすまでを書いておきます。（まぁ、Scalaのコードはオマケみたいなものですけど…）</p>

<p>前回の記事はこちらです。</p>

<ul>
  <li><a href="http://blog.restartr.com/2011/05/09/sample-sbt-project-for-dotcloud/">ScalaをDotCloudにアップロードするためのsbtサンプル</a></li>
</ul>

<p>ちなみにDotCloudは下記バージョンにて動作しているみたいです（2011.05.28現在)</p>

<ul>
  <li>nginx 0.7.65</li>
  <li>jetty 6.1</li>
  <li>mongodb 1.8.1</li>
</ul>

<h3 id="section">作成したサンプルアプリ</h3>

<p>事情により停止する場合があるかもしれませんがご了承を。</p>

<ul>
  <li><a href="http://samplemongo.ramee.dotcloud.com/">http://samplemongo.ramee.dotcloud.com/</a></li>
</ul>

<h3 id="dotcloudmongodb">DotCloudにMongoDBサーバーを準備する</h3>

<p>DotCloudのMongoDBマニュアルはこちら</p>

<ul>
  <li><a href="http://docs.dotcloud.com/components/mongodb/">MongoDB ? DotCloud documentation</a></li>
</ul>

<p>上記マニュアルにしたがって作成すればMongoDBサーバーを準備できます。
基本的には、追加したいサーバーを登録して、ユーザーを作成するだけです。</p>

<p>簡単。</p>

<p>今回は”example.mongo”という名前で作成する例を記してありますので、
それぞれ自分の作成したいアプリ名に読み替えて下さい。</p>

<h4 id="section-1">サーバーを作成</h4>

<p>事前に”dotcloud create example”は実行してあるものとします。
詳しくはこちらの<a href="http://docs.dotcloud.com/tutorials/firststeps/#id2">マニュアル</a>を見てください。</p>

<p><code>bash
$ dotcloud deploy -t mongo example.mongo
</code></p>

<p><code>bash
&gt; Created "example.mongo".
</code></p>

<h4 id="dbidpass">DB情報を確認（ID/PASS）</h4>

<p><code>bash
$ dotcloud info example.mongo
</code></p>

<p>deployコマンド実行してから実際に作成されるまで少し時間がかかります。
すぐにinfoコマンドを実行すると下記エラーがでます。
※正確に測ってませんが数十秒くらい？</p>

<p><code>bash
&gt; Sat May 28 08:14:43 Error: couldn't connect to server 127.0.0.1 shell/mongo.js:79
&gt; exception: connect failed
&gt; Connection to mongo.example.dotcloud.com closed.
&gt; Abort.
</code></p>

<p>作成完了していれば、下記情報が表示されますので、”mongodb_password: <strong>**</strong>“に記載されたパスワードをメモしておきます。</p>

<p><code>bash
cluster: wolverine
config:
    mongodb_password: ******
created_at: 1306570413.6722209
name: example.mongo
namespace: example
ports:
-   name: ssh
    url: ssh://mongodb@mongo.example.dotcloud.com:5906
-   name: mongodb
    url: mongodb://root:******@mongo.example.dotcloud.com:5907
state: running
type: mongodb
</code></p>

<h4 id="mongodb">MongoDBサーバーへログイン</h4>

<p><code>bash
$ dotcloud run example.mongo mongo
</code></p>

<p>infoコマンドで表示されたパスワードを使って、”sampledb”というdbにアプリユーザーを追加します。</p>

<p><code>bash
&gt; use sampledb
switched to db sampledb
&gt; db.getSisterDB("admin").auth("root", "&lt;infoコマンドで表示されるパスワード&gt;");
1
&gt; db.addUser("APPUSER_NAME", "APPPUSER_PASS");
{
     "user" : "APPUSER_NAME",
     "readOnly" : false,
     "pwd" : "xxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
}
&gt; exit
bye
Connection to mongo.example.dotcloud.com closed.
</code></p>

<p>※とりあえず一旦ログアウトしてますが、別に必須じゃないです。</p>

<h4 id="section-2">再度ログインしてテスト操作してみる</h4>
<p><code>bash
$ dotcloud run example.mongo mongo
</code></p>

<p>新規作成したユーザーでDB操作が可能か確認してみます。</p>

<p><code>bash
# mongo
Warning: Permanently added '[mongo.example.dotcloud.com]:5906,[174.129.17.131]:5906' (RSA) &gt; to the list of known hosts.
MongoDB shell version: 1.8.1
connecting to: test
&gt; use sampledb;
switched to db sampledb
&gt; db.auth("sampleuser", "samplepass");
1
&gt; db.sampledb.save({id:1,name:"foo"});
&gt; db.sampledb.find();
{ "_id" : ObjectId("4de0b033a1fd29eb0e1522fd"), "id" : 1, "name" : "foo" }
</code></p>

<p>問題なさそうなので、あとはアプリを”dotcloud push”して動かすだけです。</p>

<h3 id="scala">scalaからアクセスするサンプル</h3>

<p>サービス名を「example.samplemongo”として作成する例です。</p>

<p>requirementsはイカのとおり。</p>

<ul>
  <li>scala 2.9.0</li>
  <li>sbt 0.7.7</li>
  <li>jetty 7.3.1.v20110307</li>
  <li>casbah 2.1.5.0</li>
</ul>

<p><code>sbt</code>
で基本ディレクトリを作成したら、下記プロジェクト設定を{root}/project/build/MongoSampleProject.scala”として保存します。</p>

<p>前回の設定クラスをコピーしてきたので、”sbt dot_create”と”sbt dot_push”も一応使えます。</p>

<p>※”example.mongo”の名称は適宜読み替えでお願いします。
##### MongodbSampleProject.scala</p>

<script src="https://gist.github.com/996769.js?file=MongodbSampleProject.scala"></script>

<p>配置できたら、</p>

<p><code>bash
sbt reload update
</code></p>

<p>でライブラリを読み込みます。</p>

<p>あとは下記Servletの実装とweb.xmlを用意したらOK．</p>

<h5 id="mongodbservletscala">MongodbServlet.scala</h5>

<script src="https://gist.github.com/996769.js?file=MonbodbServlet.scala"></script>

<h5 id="webxml">web.xml</h5>

<script src="https://gist.github.com/996769.js?file=web.xml"></script>

<p>できたら、”sbt dot_push”でdotcloudへアップロードされるはずです。</p>

<p>最後に、”http:／／samplemongo.exapmle.dotcloud.com”にアクセスして、フォームからデータ登録ができれば成功です。</p>

<p>RDBMSにくらべてデータ保存・取得までが圧倒的に簡単で、PaaSでもMongoDBはいい感じですね！</p>

]]></content>
  </entry>
  
</feed>

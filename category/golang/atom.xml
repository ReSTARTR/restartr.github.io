<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: golang | I Will Survive]]></title>
  <link href="http://blog.restartr.com/category/golang/atom.xml" rel="self"/>
  <link href="http://blog.restartr.com/"/>
  <updated>2016-03-06T14:14:17+09:00</updated>
  <id>http://blog.restartr.com/</id>
  <author>
    <name><![CDATA[ReSTARTR]]></name>
    <email><![CDATA[yoshida.masaki+restartr@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ec2-ls-hosts: EC2インスタンスを一覧するだけのシンプルツール]]></title>
    <link href="http://blog.restartr.com/2016/02/27/ec2-ls-hosts/"/>
    <updated>2016-02-27T17:28:53+09:00</updated>
    <id>http://blog.restartr.com/2016/02/27/ec2-ls-hosts</id>
    <content type="html"><![CDATA[<p>EC2インスタンスの一覧を表示するツールをgolangでつくりました。</p>

<ul>
  <li><a href="https://github.com/ReSTARTR/ec2-ls-hosts">ReSTARTR/ec2-ls-hosts</a></li>
</ul>

<p>以下のように、ただインスタンスの情報を列挙するだけのシンプルなツールです。</p>

<p><code>bash
$ ls-hosts
i-00001 10.0.0.1 app01
i-00002 10.0.0.2 app02
i-00003 10.0.0.3 app03
i-00004 10.0.0.4 app04
</code></p>

<h3 id="section">何がうれしいか</h3>

<p>以下のような状況において、多少便利になるツールです。</p>

<ul>
  <li>EC2インスタンスを複数台運用している</li>
  <li>台数が数十台規模である</li>
  <li>AutoScalingを利用していて、IPやドメインが頻繁に変わる</li>
  <li><code>aws ec2 describe-instances</code>のレスポンスが遅い</li>
  <li><code>aws ec2 describe-instances</code>のオプション指定が複雑かつ指定が面倒</li>
</ul>

<p>このような状況を改善するため、ec2-ls-hostsをつくりました。
このツールは、<code>aws ec2 describe-instances</code>に変わる、シンプルなオプションを備えたCLIツールになります。</p>

<h3 id="ec2-ls-hosts">ec2-ls-hostsで出来ること</h3>

<p>主に以下のオプションを備えています</p>

<ul>
  <li><code>-filters</code>: 絞込み条件</li>
  <li><code>-tags</code>   : タグによる絞込み</li>
  <li><code>-fileds</code> : 表示項目の設定</li>
</ul>

<p>実行時のオプションでも指定できるのですが、いちいち指定するのは面倒なので、<code>~/.ls-hosts</code> か <code>/etc/ls-hosts</code> に設定を保存できます。
このファイルが存在していたらそれを読み込みます。(両方ある場合は<code>~/.ls-hosts</code>のほうが優先されます)
設定はこんなかんじで。</p>

<p><code>
[options]
tags   = Env:production,Role:app
fields = instance-id,tag:Name,public-ip,instance-state
</code></p>

<p>認証は以下の優先順位で可能なものを利用します。</p>

<ul>
  <li>環境変数 <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code></li>
  <li>SharedCredentials (<code>~/.aws/credentials</code>のdefaultプロファイルを利用)</li>
  <li>EC2 Instance Profile</li>
</ul>

<p>インスタンスプロファイルに対応しているので、たとえばEC2のReadOnly権限をを付与してあるゲートウェイインスタンスに配置することで、認証情報を直接管理せずに利用することもできます。</p>

<h3 id="section-1">インストール方法</h3>

<p><code>
git clone https://github.com/ReSTARTR/ec2-ls-hosts.git
cd ./ec2-ls-hosts
make build -B
cp ./build/ls-hosts /path/to/bin/ls-hosts
</code></p>

<ul>
  <li>コマンド名は<code>ls-hosts</code>にしています。</li>
  <li><code>$PATH</code>の通っているところに配置してください:bow:</li>
</ul>

<h3 id="zsh--pecossh">zsh + pecoでインタラクティブにSSHする</h3>

<p>ec2-ls-hosts単体でも多少便利にはなるのですが、ツールを組み合わせた応用例も書いておきます。</p>

<p>たとえば以下のような結果が得られるEC2環境があったとします。</p>

<p><code>
$ ls-hosts -filters instance-state-name:running -tags Env:production,Role:app -fields private-ip,tag:Name,tag:Role
10.0.0.1 app app01
10.0.0.2 app app02
10.0.0.3 app app03
</code></p>

<p>これをpecoでインタラクティブに選択してそのままSSHするには、以下のようにzshrcを設定しておきます。</p>

<p><code>
function peco-ec2-ls-hosts () {
  # NOTE: ~/.ls-hostsに設定したほうがより良いです
  BUFFER=$(
    ls-hosts -filters instance-state-name:running -tags Env:production,Role:app -fields private-ip,tag:Name,tag:Role | \
    peco --prompt "EC2 &gt;" --query "$LBUFFER" | \
    awk '{echo "Login to %s; printf "ssh %s\n", $3,$1}'
  )
  CURSOR=$#BUFFER
  zle accept-line
  zle clear-screen
}
zle -N peco-ec2-ls-hosts
# キーバインドはおこのみで
bindkey '^oo' peco-ec2-ls-hosts
</code></p>

<p>とすることで、インタラクティブにSSHできてヒストリーにも残ります。
以下キャプチャでは対象インスタンスがダミーなのでSSできてませんがちゃんと使えます。
(実環境の実行結果は載せられないので泣く泣くダミーです…)</p>

<p><a href="https://gyazo.com/ae45206ad8215934f5e0a897b91b3d2a"><img src="https://i.gyazo.com/ae45206ad8215934f5e0a897b91b3d2a.gif" alt="https://gyazo.com/ae45206ad8215934f5e0a897b91b3d2a" /></a></p>

<p>※クライアントPCからパブリックIPとかで直接SSHできない場合はプロキシコマンドを利用して踏み台経由とかでプライベートIPできるssh-configを設定しておくと、この応用例を使って透過的にSSHできます（これは別記事としたほうがよいかも？)</p>

<h3 id="section-2">余談</h3>

<p>さいごの応用例はもともとaws-cli + jq + pecoで実現していたのですが、管理台数が増えるに連れてレスポンスが極端に劣化。
キャッシュ機構を入れてみたりしたものの、快適とはいえない状況になったので、「aws-sdk-goで書くだけで軽くなるのでは？」という発想から開発に至りました。</p>

<p>mackerel導入環境であれば<code>mkr</code>でも似たようなことができるかもしれないですが、mackerel前提ではないソリューションとしても十分使えるかな、と。</p>

<p>社内利用に特化したかたちでつくったものの、ちょっとだけ汎用化すればべつに誰でも使えるようなきがしたので、手を加えたうえでgithubにて公開となりました。
まだまだ貧弱ですが、最低限役目は果たしています。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker謹製ライブラリのlibchanについて調べてみた]]></title>
    <link href="http://blog.restartr.com/2014/06/28/about-docker-libchan/"/>
    <updated>2014-06-28T14:44:23+09:00</updated>
    <id>http://blog.restartr.com/2014/06/28/about-docker-libchan</id>
    <content type="html"><![CDATA[<p>DockerCon2014で発表された<a href="https://github.com/docker/libchan">libchan</a>について調べたことをまとめてみます。</p>

<p>libchanは<a href="https://github.com/docker/libcontainer">libcontainer</a>や<a href="https://github.com/docker/libswarm">libswarm</a>と共に発表されました。
libswarmはDockerを中心にしたエコシステムにおけるベンダーロックインを回避するためのソリューションであり、libcontainerは<a href="http://d.hatena.ne.jp/mainyaa/20140311/p1">Docker 0.9リリースドキュメント日本語訳: Execution driversとlibcontainer導入 - Happy New World</a>を参照するのがよいでしょう。</p>

<p>では、libchanとは何なのでしょうか。</p>

<p>READMEには<code>like Go channels over the network</code>とあります。ネットワーク上のgo channel?よくかりませんね。。。</p>

<p>README.mdとPROTOCOL.md、いくつかのテストコードをもとに簡単な実装をしてみた結果をまとめます。</p>

<h3 id="libchan">libchanとはなにか</h3>

<ul>
  <li><a href="https://github.com/docker/libchan/README.md">README</a></li>
</ul>

<p>libchanは超軽量なネットワークライブラリであり、多様な通信プロトコルの土台となるものです。
同一プロセス内でも、同一ホストの別プロセス間でも、ネットワークを超えた別ホストの別プロセス間でも双方向通信可能にするための基礎的なAPIを提供しています。
モダンなmicro-serviesなどRPCやRESTプロトコルにはフィットしない領域で、libchanを使うことが想定されています。</p>

<p>利用例はいまのところlibswarmのみです。というかlibswarmから抽出された汎用的な通信ライブラリだと思います。
APIが安定してくると他のフレームワーク等への導入などもあるかもしれません。</p>

<p>では、具体的にどうやって双方向通信を可能にしてるのでしょう。</p>

<h3 id="libchan-1">libchanのプロトコル</h3>

<ul>
  <li><a href="https://github.com/docker/libchan/PROTOCOL.md">PROTOCOL</a></li>
</ul>

<p>libchanは以下のコンポーネントで構成されています。</p>

<ul>
  <li>channel</li>
  <li>session</li>
  <li>message</li>
  <li>byte stream</li>
  <li>nesting</li>
</ul>

<p>channelとは、並行プログラム間の双方向通信用オブジェクトです。goのchannelに似てるけどそのものではありません。Sender/Receiverがそれぞれ1方向ずつの経路を持つため、ソケットというよりパイプの概念に近いです。</p>

<p>この２つの通信経路がsessionとなり、その間を流れるのがbyte stream。
で、byte streamにはmessageが乗っかり、messageにはchannelを含めることができるという概念です。</p>

<h3 id="libchan-2">libchanのメッセージ</h3>

<p>メッセージはlibchan.Message。</p>

<p><code>go
type libchan.Message struct {
  Data []byte // メッセージの内容
  Fd *os.File
  Ret Sender  // 受信者が返答するためのchannel
}
</code></p>

<p>このメッセージ型を、各種通信方式に対応したSender/Receiver経由でやりとりすることになります。</p>

<h3 id="section">メッセージの構造化</h3>

<p>メッセージは以下のようにして生成します。</p>

<p><code>go
message := libchan.Message{Data: []byte("Hello, libchan"), Ret: libchan.RetPipe}
</code></p>

<p>で、ただのテキストではなく構造化されたデータも送れます。</p>

<p>```go
import “github.com/docker/libchan/data”</p>

<p>d := data.Empty().Set(“foo”, “bar”)
d.Get(“foo”) // “bar”
d.Pretty() // foo=bar
message := libchan.Message{Data: d, Ret: libchan.RetPipe))
```</p>

<p>ちなみに、各メソッド(Add,Set,Get,Del)はMessageのポインタをかえさないので、変数を上書きするかメソッドチェインにする必要があります。</p>

<h3 id="section-1">メッセージの送受信</h3>

<p>作成したメッセージををSender経由で送ります。（ここでのSender/Receiverは擬似コードです）</p>

<p><code>go
sender.Send(&amp;libchan.Message{Data: []byte(msg)})
</code></p>

<p>で、Receiverが受信したメッセージは<code>data.Decode()</code>で<code>map[string][]string</code>に変換できます。</p>

<p><code>go
message, _ := receiver.Receive(0)
decoded, _ := data.Decode(string(message.Data))
fmt.Printf("%$v\n", docoded) // map[string][]string{"foo":[]string{"bar"}}
</code></p>

<h3 id="senderreceiver">Sender/Receiver</h3>

<p>実際にメッセージを送受信するのは、Send/Receiverメソッドを持つinterfaceを実装したものを使います。
定義はだいたいこんなかんじになっています。</p>

<p>```go
type Sender interface {
  Send(msg *Message) (Receiver, error)
}</p>

<p>func (s *Sender) Send(msg *libchan.Message) (libchan.Receiver, error)</p>

<p>type Receiver interface {
  Receiver(mode int) (*Message, error)
}</p>

<p>func (r <em>Receiver) Receive(mode int) (</em>libchan.Message, error)
```</p>

<p>主要な実装は以下</p>

<ul>
  <li><a href="https://github.com/docker/libchan/blob/master/nop.go">nop</a></li>
  <li><a href="https://github.com/docker/libchan/blob/master/inmem.go">inmem</a></li>
  <li><a href="https://github.com/docker/libchan/blob/master/unix">unix</a></li>
  <li><a href="https://github.com/docker/libchan/blob/master/http2">http2</a></li>
</ul>

<h3 id="inmem-in-memory-go-channel">inmem (In-memory Go channel)</h3>

<p><a href="https://github.com/docker/libchan/blob/master/inmem_test.go">inmem_test.go</a>を参考に実装してみます。</p>

<p>まずは<code>libchan.Pipe()</code>を使って、receiver/senderを取得します。</p>

<p><code>go
receiver, sender := libchan.Pipe()
</code></p>

<p>送信側はgorutine内でsender経由でメッセージを送信して、送信側から受信したメッセージに対してさらに返信します。</p>

<p><code>go
go func() {
  recv, _ := sender.Send(&amp;libchan.Message{
    Data: []byte("Hello"),
    Ret: libchan.RetPipe,
  )
  msg, _ := recv.Receive(0) // mode=0で自動Close()
  fmt.Println(string(msg.Data)) // "World"
}()
</code></p>

<p>受信側はreceiver経由でメッセージ受信して、それに対して返信します。</p>

<p><code>go
msg, err := receiver.Receive(libchan.Ret)
fmt.Println(string(msg.Data)) // "Hello"
// msg.Retが返信用のchannelとなっている
_, err := msg.Ret.Send(&amp;libchan.Message{Data: []byte("World")})
</code></p>

<h3 id="unixhttp2">unix/http2の実装</h3>

<p>それぞれにテストコードがあるので覗いてみるとだいたいのイメージがつかめます。</p>

<ul>
  <li><a href="https://github.com/docker/libchan/blob/master/unix/unix_test.go">unix/unix_test.go</a></li>
  <li><a href="https://github.com/docker/libchan/blob/master/http2/listener_test.go">http2/listener_test.go</a></li>
</ul>

<h2 id="section-2">まとめ</h2>

<p>libchanにおけるchannelとgoのchannel、名前は同じでも別モノです。
今のところこれといった用途が思いつかないですが、libswarmから派生したものとすると多様なプロトコルの差異を吸収するためのアダプター実装を手助けしてくれるレイヤーと考えるのがよさそうです。</p>

<p>というか、DockerConでちょくちょく言及されていた「マイクロサービス」という概念のほうが興味あります。</p>

<h2 id="section-3">追記</h2>

<blockquote class="twitter-tweet" lang="ja"><p>そういえば書き忘れてたけど、アプリケーションが成長する過程においてlibchanの統一的なインターフェースによって比較的容易にスケールできるんだよ、ってことをDockerConのキーノートでいってたような。。。あとでみかえそう。</p>&mdash; Masaki YOSHIDA (@ReSTARTR) <a href="https://twitter.com/ReSTARTR/statuses/482775493511376896">2014, 6月 28</a></blockquote>
<script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>ということに気づき、再度キーノートを見返してました。libchanについては以下動画の30:45あたりからどうぞ。</p>

<iframe width="640" height="360" src="//www.youtube.com/embed/_DOXBVrlW78" frameborder="0" allowfullscreen=""></iframe>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Goでmemcachedのstatsを取得する]]></title>
    <link href="http://blog.restartr.com/2014/04/21/golang-memcache-stats-client/"/>
    <updated>2014-04-21T00:17:33+09:00</updated>
    <id>http://blog.restartr.com/2014/04/21/golang-memcache-stats-client</id>
    <content type="html"><![CDATA[<p>YouTubeで使われている<a href="https://github.com/youtube/vitess">vitess</a>の実装をざっと見てたところ、memcachedクライアント実装が簡潔でわかりやすかったので出来る限りラフに実装を写経してみました。</p>

<p>やってることはコマンドラインからアドレスを受け取って、memcachedのstatsを表示するだけです。</p>

<h3 id="section">この写経で学べること</h3>

<ul>
  <li>flagパッケージを使ったコマンドライン引数の取得</li>
  <li>netパッケージを使ったネットワーク接続</li>
  <li>bufioパッケージを使ったストリームの読み出し</li>
</ul>

<h3 id="main">main()</h3>

<p>```go
func main() {
	// 引数読み出し
	address := flag.String(“address”, “localhost:11211”, “server address”)
	flag.Parse()
	fmt.Printf(“server: %s\n”, *address)</p>

<pre><code>// サーバーに接続
conn, err := GetConn(*address)
if err != nil {
	fmt.Printf("%#v", err)
	os.Exit(1)
}
defer conn.conn.Close()

// stats読み出し
result, _ := conn.Stats()
fmt.Printf("%s", result) } ```
</code></pre>

<h3 id="section-1">実行結果</h3>

<p><code>bash
$ go run ./memcache_stats.go --address=localhost:11211
server: localhost:11211
STAT pid 23282
STAT uptime 12425
STAT time 1398007875
STAT version 1.4.4
STAT pointer_size 64
STAT rusage_user 0.335948
STAT rusage_system 0.344947
  :
</code></p>

<h3 id="section-2">実装全体</h3>

<p><div><script src='https://gist.github.com/11116595.js?file=memcache_stats.go'></script>
<noscript><pre><code>package main                                                                                                                                                                          [32/1268]

// 写経 from: https://github.com/youtube/vitess/blob/master/go/memcache/memcache.go
//  * エラーハンドリングをできるかぎり省略して実装.
//  * statsコマンドだけ実装

import (
        &quot;bufio&quot;
        &quot;flag&quot;
        &quot;fmt&quot;
        &quot;net&quot;
        &quot;os&quot;
        &quot;strings&quot;
)

type Connection struct {
        conn net.Conn
        buffered bufio.ReadWriter
}

func GetConn(address string) (conn *Connection, err error) {
        nc, err := net.Dial(&quot;tcp&quot;, address)
        if err != nil {
                return nil, err
        }
        return &amp;Connection{
                conn: nc,
                buffered: bufio.ReadWriter{
                        Reader: bufio.NewReader(nc),
                        Writer: bufio.NewWriter(nc),
                },
        }, err
}

func (mc *Connection) writestring(s string) {
        _, err := mc.buffered.WriteString(s);
        if err!= nil {
                panic(err)
        }
}

func (mc *Connection) readline() string {
        mc.flush()
        l, _, _ := mc.buffered.ReadLine()
        return string(l)
}

func (mc *Connection) flush() {
        err := mc.buffered.Flush()
        if err != nil {
                panic(err)
        }
}

func (mc *Connection) Stats() (result []byte, err error) {
        mc.writestring(&quot;stats\r\n&quot;)
        mc.flush()
        for {
                l := mc.readline()
                if strings.HasPrefix(l, &quot;END&quot;) {
                        break
                }
                if strings.Contains(l, &quot;ERROR&quot;) {
                        panic(&quot;ERROR&quot;)
                }
                result = append(result, l...)
                result = append(result, &#39;\n&#39;)
        }
        return result, err
}

func main() {
        address := flag.String(&quot;address&quot;, &quot;localhost:11211&quot;, &quot;server address&quot;)
        flag.Parse()
        fmt.Printf(&quot;server: %s\n&quot;, *address)

        conn, err := GetConn(*address)
        if err != nil {
                fmt.Printf(&quot;%#v&quot;, err)
                os.Exit(1)
        }
        defer conn.conn.Close()

        result, _ := conn.Stats()
        fmt.Printf(&quot;%s&quot;, result)
}</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GoとPythonをZeroMQで繋ぐ]]></title>
    <link href="http://blog.restartr.com/2013/04/26/connect-go-and-python-with-zeromq/"/>
    <updated>2013-04-26T23:34:48+09:00</updated>
    <id>http://blog.restartr.com/2013/04/26/connect-go-and-python-with-zeromq</id>
    <content type="html"><![CDATA[<p>最近Rubyでプロジェクトオイラーを解きながらRubyに慣れようとしてるのですが、ちょっと飽きてきたので息抜きにGoを書いたりしています。</p>

<p>ついでにZeroMQも試してみたかったので、GoとPythonをZeroMQで繋いでみました。</p>

<p>構成はこんな感じで、Python(かGo)clientを起動し、Goで動くmonitorq経由でGoのserverにつながります。PUB/SUBでmonitorからモニタリングできるのがミソです。</p>

<p><code>ruby
                  +----------------------------------------+
                  |                                        |
  +------+        |--------------------------+     +-----+ |
  |client|--------|9001     monitorq     9002|-----|serv | |
  |(REQ) |        |(ROUTER)   9003   (DEALER)|     |(REP)| |
  +------+        |--------------------------+     +-----+ |
                  |          |(PUB)                        |
                  |          |                             |
                  |          |                             |
                  |          |(SUB)                        |
                  |      +-------+                         |
                  |      |monitor|                         |
                  |      +-------+                         |
                  +----------------------------------------+
</code></p>

<p><em>※client/server/monitorは複数たちあげるとよしなに振り分けてくれます。</em></p>

<ul>
  <li>monitorqでfan-in/outする</li>
</ul>

<p><code>bash
$ go run queue.go monitorq
</code></p>

<ul>
  <li>clientから”PING”を投げる(と、”PONG#<pid>"が帰る)</pid></li>
</ul>

<p><code>bash
$ python run queue.py client
PONG#&lt;28870&gt;
PONG#&lt;28870&gt;
 :
</code></p>

<ul>
  <li>serverから”PONG”を返す(clientからのPINGを表示)</li>
</ul>

<p><code>bash
$ go run queue.go serv
Recv: PING#&lt;73835&gt;
Recv: PING#&lt;73835&gt;
 :
</code></p>

<ul>
  <li>monitorでリクエスト総数をモニタリング</li>
</ul>

<p><code>bash
$ go run queue.go monitor
MONITOR: IN: 2082, OUT 2082
MONITOR: IN: 2083, OUT 2083
 :
</code></p>

<p>コードはgistにあげてます。</p>

<ul>
  <li><a href="https://gist.github.com/ReSTARTR/5467656">gist</a></li>
</ul>

<p>ZeroMQなら他にもいろんな構成がとれるので、使いどころは結構あるのではないかと。</p>

<p>今回、不慣れなGoで書いてみましたが、これくらいであればもわりと素直にかけるなぁという印象です。</p>

<p>Goで書かれたZeroMQのサンプルは以下githubリポジトリにたくさんあるので、覗いてみると色々勉強になります。</p>

<ul>
  <li><a href="https://github.com/imatix/zguide/tree/master/examples/Go">zguide/examples/Go at master ? imatix/zguide</a></li>
</ul>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 入門 自然言語処理 | I Will Survive]]></title>
  <link href="http://blog.restartr.com/category/ru-men-zi-ran-yan-yu-chu-li/atom.xml" rel="self"/>
  <link href="http://blog.restartr.com/"/>
  <updated>2016-02-20T00:09:22+09:00</updated>
  <id>http://blog.restartr.com/</id>
  <author>
    <name><![CDATA[ReSTARTR]]></name>
    <email><![CDATA[yoshida.masaki+restartr@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[入門 自然言語処理 第一章]]></title>
    <link href="http://blog.restartr.com/2011/02/13/analysing-text-with-the-natual-language-toolkit-chap1/"/>
    <updated>2011-02-13T09:00:29+09:00</updated>
    <id>http://blog.restartr.com/2011/02/13/analysing-text-with-the-natual-language-toolkit-chap1</id>
    <content type="html"><![CDATA[<p><a href="http://www.amazon.co.jp/dp/4873114705/">入門 自然言語処理</a>は11月に購入してから寝かせたままでしたが、本日より読み始めることにしました。</p>

<p>本日は第一章です。内容は大きく以下2点。</p>

<ul>
<li>pythonとnltkでの簡単なテキスト処理方法</li>
<li>自然言語処理を俯瞰する</li>
</ul>
<p>内容は本に任せるとして、ここでは演習問題の解答をしようと思います。</p>

<p><a id="more"></a><a id="more-588"></a></p>

<p>問題文は簡潔に記述するため、本書に記載されているものとは異なる表記をしています。</p>

<h3>納得いかない問題</h3>
<p>ひとつだけ納得いかない問題がありました。
「<i>17. text9からtext.9.index()を使って’sunset’を含む一文を抜き出す</i>」です。</p>

<p>解答をググっても、こちらしか出てこず。
<a href="http://sojin.kyoto-math.jp/nlp/1-3.html#id1">1-15. bで始まる単語抽出 — 入門自然言語処理</a></p>

<p>たしかに、</p>

<pre class="brush:python">
&gt;&gt;&gt; text9.index('sunset')
629
</pre>
<p>と帰ってきます。でも、実際には’sunset’を含む一文は複数あるわけです。
確認するとこんな感じ。</p>

<pre class="brush:python">
&gt;&gt;&gt; [t for t in text9 if t=='sunset']
['sunset', 'sunset', 'sunset', 'sunset', 'sunset', 'sunset', 'sunset', 'sunset', 'sunset', 'sunset', 'sunset', 'sunset', 'sunset', 'sunset']
</pre>
<p>複数ある一文を抽出しなくていいの？という疑問が出てきました。すべての文を抽出する方法はさておき、今回はひとつだけ抽出する解答だけを書きました。</p>

<h3>演習問題</h3>
<h4>準備</h4>
<p>nltkとmatplotlibがインポートできていれば、以下コードだけですみます。</p>

<pre class="brush:python">from nltk.book import *</pre>
<p>以下が、すべての問題の解答です。
(私個人の解答であり、正解の保証はどこにもありません。）</p>

<h4>1. Pythonインタプリタを電卓として、12 / (4 + 1)のような計算を入力してみよう</h4>
<pre class="brush:python">&gt;&gt;&gt; 12 / 4 + 1
2.3999999999999999</pre>
<h4>2. 26文字のアルファベットが与えられたとき、10字の文字列は26の10乗（あるいは26**10）種類も作ることができるが、100文字だったら何種類か。</h4>
<pre class="brush:python">&gt;&gt;&gt; 26 ** 100
3142930641582938830174357788501626427282669988762475256374173175398995908420104023465432599069702289330964075081611719197835869803511992549376L</pre>
<h4>3. ['Monty', 'Python'] * 20や 3 * sent1を実行すると何が起こるか</h4>
<pre class="brush:python">&gt;&gt;&gt; ['Monty', 'Python'] * 3
['Monty', 'Python', 'Monty', 'Python', 'Monty', 'Python']</pre>
<h4>4. text2には単語がいくつ含まれているか。また重複を除くといくつか。</h4>
<pre class="brush:python">&gt;&gt;&gt; #単語数
&gt;&gt;&gt; len(text2)
141576
&gt;&gt;&gt; #重複除いた単語数
&gt;&gt;&gt; len(set(text2))
6833</pre>
<h4>5. ユーモア小説とロマンス小説の間で、どちらが語彙の多様性が高いか。</h4>
<ul>
<li>ユーモア小説：多様性＝6.9</li>
<li>ロマンス小説：多様性＝8.3</li>
</ul>
<p>?ロマンス小説が高い。</p>

<h4>6. Sense and Sensibilityのなかで、エリナ、マリアン、エドワード、ウィロビーの分散プロットを表示してみよう。</h4>
<p>名前まで日本語表記されていて元の綴りがわからない…
なのでまず探すところから。</p>

<pre class="brush:python">&gt;&gt;&gt;[t for t in set(text2) if t.startswith('El')]
['Elinor', 'Eliza']</pre>
<p>な感じで4人分探します。
で、プロットする</p>

<pre class="brush:python">&gt;&gt;&gt; text2.dispersion_plot(['Elinor', 'Mrianne', 'Edward', 'Willoughbys'])
# ※ここでプロットウインドウが表示される
</pre>
<h5>男女の役割の違い</h5>
<p>女性が高頻度に出現</p>

<h5>カップルの特定は可能か</h5>
<p>できない。どうしろと…</p>

<h4>7. text5のコロケーションを探してみよう。</h4>
<pre class="brush:python">&gt;&gt;&gt; text5.collocations()
Building collocations list
wanna chat; PART JOIN; MODE #14-19teens; JOIN PART; PART PART;
cute.-ass MP3; MP3 player; JOIN JOIN; times .. .; ACTION watches; guys
wanna; song lasts; last night; ACTION sits; -...)...- S.M.R.; Lime
Player; Player 12%; dont know; lez gurls; long time</pre>
<h4>8. len(set(text4))の目的</h4>
<p>単語のユニーク数を求める</p>

<h4>9. リストと文字列</h4>
<h5>(a) 変数の定義と2種類の出力を試してみよう</h5>
<pre class="brush:python">&gt;&gt;&gt; my_string = 'My String'
&gt;&gt;&gt; my_string
My String
&gt;&gt;&gt; print my_string
My String
</pre>
<h5>(b). 連結と演算</h5>
<pre class="brush:python">&gt;&gt;&gt; my_string + my_string 
'My StringMyString'
&gt;&gt;&gt; my_string * 3 
'My StringMy StringMy String'
</pre>
<h4>10. 単語のリストを保持するmy_sentという変数を定義しよう</h4>
<h5>(a) ' '.joiin(my_sent)を使ってリストを文字列に変換してみよう。</h5>
<pre class="brush:python">&gt;&gt;&gt; ' '.join(my_string.split(' '))
'My String'
</pre>
<h5>(b) split()を使ってできた</h5>
<pre class="brush:python">&gt;&gt;&gt; my_sent = ['My', 'Sent']
&gt;&gt;&gt; ' '.join(my_sent)
'My Sent'
&gt;&gt;&gt; ' '.join('hoge moge'.split(' '))
'My Sent'
</pre>
<h4>11. リストの連結</h4>
<pre class="brush:python">&gt;&gt;&gt; phrase1 = ['hoge']
&gt;&gt;&gt; phrase1 += ['moge']
&gt;&gt;&gt; phrase2 = ['foo']
&gt;&gt;&gt; phrase2 += ['bar']
&gt;&gt;&gt; phrase1 + phrase2
['hoge', 'moge', 'foo', 'bar']</pre>
<h5>len(phrase1 + phrase2)とlen(phrase1) + len(phrase2)の違いはなにか。</h5>
<p>連結した後の長さと、それぞれの長さの加算</p>

<h4>12. NLPと関連あるものはどれか。</h4>
<ul>
<li>['Monty Python'][6:12]</li>
<li>['Monty', 'Python'][1]</li>
</ul>
<p>?b</p>

<h4>13. sent1[2][2]はなにを表しているだろうか。</h4>
<p>2要素目の2文字目</p>

<h4>14.  要素のインデックス取得</h4>
<p>微妙だけど。</p>

<pre class="brush:python">&gt;&gt;&gt; i = 0
&gt;&gt;&gt; for t in sent3:
...   if t=='the':
...     print i
...   i += 1
...
1
5
8</pre>
<h4>15. bから始まる単語の取得</h4>
<pre class="brush:python">&gt;&gt;&gt; sorted(set([t for t in text5 if t.startswith('b')]))
['b', 'b-day', 'b/c', 'b4',......</pre>
<h4>16. range()について</h4>
<pre class="brush:python">&gt;&gt;&gt; range(10)
[1,2,3....9]
&gt;&gt;&gt; range(10,20)
[10,11,12,...., 20]
&gt;&gt;&gt; range(10,20,2)
[10, 12, ..., 18]
&gt;&gt;&gt; range(20,10,-2)
[20, 18, ..., 12]</pre>
<h4>17. text9からtext.9.index()を使って'sunset'を含む一文を抜き出す</h4>
<p>これで良いのかわかりませんが、ひとまずの解答として。</p>

<pre class="brush:python">
dot_pre = 0 # 直前の'.'の位置
dot_aft = 0 # 直後の'.'の位置
found = False # '.'が見つかったかどうか
i = 0 # 現在位置
for t in text9:
  if t=='sunset':
    found = True
  if t=='.':
    if found==True:
      dot_aft = i
      break
    else:
      dot_pre = i
  i += 1
# 'sunset'を含む一文を生成する。
' '.join([text9[t] for t in range(dot_pre+1, dot_aft+1)])
# 'CHAPTER I THE TWO POETS OF SAFFRON PARK THE suburb of Saffron Park lay on the sunset side of London , as red and ragged as a cloud of sunset .'
</pre>
<h4>18. sent1からsent8までに含まれる語彙を計算</h4>
<pre class="brush:python">len(set(sent1 + sent2 + sent3 + sent4 + sent5 + sent6 + sent7 + sent8))</pre>
<h4>19. 以下2行の違いは何か。</h4>
<pre class="brush:python">sorted(set([w.lower() for w in text1]))
sorted([w.lower() for w in set(text1)])</pre>
<h5>sorted(set([w.lower() for w in text1]))</h5>
<p>小文字のリストを作ってからユニークにしてソート</p>

<h5>sorted([w.lower() for w in set(text1)])</h5>
<p>ユニークリストから小文字にしてソート
こちらが大きい。重複をふくんでいるので。</p>

<h4>20. w.isupper()とw.islower()の違いは何か</h4>
<p>大文字ならTrueと小文字ならTrue</p>

<h4>21. 最後の2単語を取り出すスライス式を書いてみよう。</h4>
<pre class="brush:python">&gt;&gt;&gt; text2[-2:]
</pre>
<h4>21. 4文字の単語のうち、頻度の高い順に取得してみよう。</h4>
<pre class="brush:python">
&gt;&gt;&gt; FreqDist([t for t in text4 if len(t)==4]).keys()
</pre>
<h4>21. 大文字の単語を一行ずつ表示</h4>
<pre class="brush:python">
&gt;&gt;&gt;  for str in [t for t in text6 if t.isupper()]:
&gt;&gt;&gt;   print str
</pre>
<h4>24. 条件にあったものを含むリスト</h4>
<h5>a: izeで終わる</h5>
<pre class="brush:python">[t for t in text6 if t.endswith('ize')]</pre>
<h5>b: zを含む</h5>
<pre class="brush:python">[t for t in text6 if 'z' in t]</pre>
<h5>c: ptを含む</h5>
<pre class="brush:python">[t for t in text6 if 'pt' in t]</pre>
<h5>d: 先頭大文字あと小文字（＝タイトルケース)</h5>
<pre class="brush:python">[t for t in text6 if t.isalpha()==True and t==t.title()]</pre>
<h4>25. listed = ['she', 'sells', 'sea', 'shells', 'by', 'the', 'sea', 'shore']</h4>
<h4></h4>
<h5>shではじまる単語</h5>
<pre class="brush:python">[t for t in listed if t.startswith('sh')]</pre>
<h5>4文字より大きい単語</h5>
<pre class="brush:python">[t for t in listed if len(t)&gt;=4]</pre>
<h4>26. sum([len(w) for w in text1])について</h4>
<h5>どんな処理？</h5>
<p>リスト中のすべての単語長の合計</p>

<h5>これをつかって平均はだせる？</h5>
<pre class="brush:python">
&gt;&gt;&gt; sum([len(w) for w in text1])/len(text1)
3.8304111280236488</pre>
<h4>27. 語彙サイズを返すvocab_size(text)を定義</h4>
<pre class="brush:python">
&gt;&gt;&gt; def vocab_size(text):
...  return len(set(text))
...
&gt;&gt;&gt; vocab(text1)
19317
</pre>
<h4>28. percent(word, text)を定義</h4>
<pre class="brush:python">
&gt;&gt;&gt; def percent(word, text):
...  return len([t for t in text if t==word]) / len(text)
</pre>
<h4>29. set(sent3) &lt; set(text1)について</h4>
<h5>実行してみる</h5>
<pre class="brush:python">True</pre>
<h5>29. 異なるテキストで実行して何が起こるか</h5>
<pre class="brush:python">&gt;&gt;&gt; set(sent3) &lt; set(text3)
True</pre>
<h5>実用的な応用は何があるか</h5>
<p>ドキュメント間の語彙数の比較</p>

<ul>
  <li><a href="http://www.amazon.co.jp/dp/4873114705">入門 自然言語処理 [大型本]</a></li>
</ul>

]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: go | I Will Survive]]></title>
  <link href="http://blog.restartr.com/category/go/atom.xml" rel="self"/>
  <link href="http://blog.restartr.com/"/>
  <updated>2015-10-22T11:38:36+09:00</updated>
  <id>http://blog.restartr.com/</id>
  <author>
    <name><![CDATA[ReSTARTR]]></name>
    <email><![CDATA[yoshida.masaki+restartr@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA["Go Programming Blueprints"を読んだ]]></title>
    <link href="http://blog.restartr.com/2015/10/15/go-programming-blueprints/"/>
    <updated>2015-10-15T19:54:29+09:00</updated>
    <id>http://blog.restartr.com/2015/10/15/go-programming-blueprints</id>
    <content type="html"><![CDATA[<p><a href="http://www.amazon.co.jp/gp/product/B00T4ACPA0)">
<img src="https://raw.githubusercontent.com/matryer/goblueprints/master/artwork/bookcover.jpg" alt="Go Blueprints by Mat Ryer book cover" />
</a></p>

<ul>
  <li><a href="http://www.amazon.co.jp/gp/product/B00T4ACPA0">Go Programming Blueprints - Solving Development Challenges with Golang</a></li>
</ul>

<p>最近Kindleで購入したので、でひととおり読んで写経してみました。</p>

<h3 id="section">概要と雑感</h3>

<p>2015年1月に発売された書籍であり、Goのバージョンでいうと1.3から1.4の頃に書かれたものです。
著者はGolang UK Conference 2015でトークもしていた<a href="https://twitter.com/matryer">@matryer</a>さん。
(<em>※<a href="https://www.youtube.com/watch?v=tIm8UkSf6RA">Golang UK Conference 2015 - Mat Ryer - Building APIs - YouTube</a></em>)</p>

<p>いくつかのGo製アプリケーション開発を通じて、Goの機能・パターンを学習する、という感じのもの。機能やパターンについて網羅的ではないものの、特定のユースケースをベースにしているため、パターンの理解は容易に感じます。取り扱うトピックも、web/apiサーバーとコマンドラインツールがバランスよく取り上げられています。</p>

<p>対象読者は「すべてのGoプログラマー」と記載がありますが、<a href="https://tour.golang.org">A Tour of Go</a>をひととおりやったあとくらいがちょうど良い気がします。</p>

<p>リファレンス的な構成の他書や<a href="https://golang.org/doc/effective_go.html">Effective Go</a>のような公式ドキュメントのものとうまくすみ分けができているのではないかと。</p>

<p>ただ誤字・脱字が少し目立つかな（章ごとに1,2個程度ですが)という点が残念ではありますが、比較的わかりやすいミスなので読んでいて混乱するほどではありません。</p>

<p><a href="https://github.com/golang/go/wiki/Books">Go Books</a>としては比較的マイナーっぽく、日本語圏の情報もないので購入はちょっとしたギャンブルでしたが、ある程度まとまったストーリーとして読めるGo関連の書籍は少ない印象ですし、自分としてはちょうど良い買い物だったかなと思います。</p>

<p><em>※ソースコードも<a href="https://github.com/matryer/goblueprints">matryer/goblueprints</a>に公開されています</em></p>

<p>_※当然英語ですが、さほど読みにくい感じはなかったです</p>

<h3 id="section-1">構成</h3>

<p>全8章で作成するアプリケーションのうち、1章で簡潔するものと章をまたがるものがあり、構成は以下のようになっています。</p>

<h4 id="websocket">1, 2, 3: websocketによるチャットアプリケーション</h4>

<ul>
  <li>http.Handle/HandleFuncの基本的な使い方とか、TDDによるパッケージ開発、</li>
  <li>ソーシャルログイン機能の追加(OAuthは<a href="https://github.com/stretchr/gomniauth">stretchr/gomniauth</a>を利用)</li>
  <li>アイコン画像のアップロード機能の追加</li>
</ul>

<h4 id="section-2">4: 空きドメイン検索ツール</h4>

<ul>
  <li>Unixコマンドのように、STDIN/OUTを使った複数コマンドによる連携
    <ul>
      <li><code>$ 単語生成 | 単語の補正 | TLDの付与 | WHOISチェック</code></li>
      <li>これらをos.Command.Stdin,Stdoutで束ねるコマンド
        <ul>
          <li><em>.o(シェルスクリプトでも良いのではと思いますが、外部プロセスとの連携の練習ということで…)</em></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="twitter">5, 6: Twitterのリアルタイムカウンター</h4>

<ul>
  <li>複数のプロセスで構成される分散システム
    <ol>
      <li>twitter streaming apiから拾ったツイートを<a href="http://nsq.io">NSQ</a>に追加するプログラム</li>
      <li>NSQのsubscriberが単語別件数を集計して、1秒ごとにMongoDBを更新するプログラム</li>
      <li>MongoDBの内容を管理・閲覧ツール(RESTful APIとWEBアプリ)</li>
    </ol>
  </li>
</ul>

<p>トピック</p>

<ul>
  <li>シグナルトラップによる安全なプロセス終了処理</li>
  <li>sync.Mutexによる協調動作の実装</li>
  <li><a href="https://github.com/stretchr/graceful">stretchr/graceful</a>での安全な終了処理</li>
</ul>

<h4 id="google-places-api">7: Google Places APIを使ったロケーション推薦アプリケーション</h4>

<ul>
  <li>iotaによるEnum相当の実現</li>
  <li>TDDでパッケージ開発
    <ul>
      <li><em>.o(ここで<a href="https://github.com/cheekybits">cheekybits/is</a>が出てきたけど、全体で統一感出してほしい…)</em></li>
    </ul>
  </li>
  <li>型アサーションによるキャスト</li>
</ul>

<h4 id="section-3">8 ファイル自動バックアップシステム</h4>

<ul>
  <li>2つのCLIツールの作成
    <ul>
      <li>backup: バックアップする対象リストの管理コマンド
        <ul>
          <li>メタデータ管理は<a href="https://github.com/mattyer/filedb">mattyer/filedb</a></li>
        </ul>
      </li>
      <li>backupd: メタデータをもとに実ファイル監視とバックアップ実行する常駐プログラム</li>
    </ul>
  </li>
</ul>

<h3 id="section-4">蛇足</h3>

<p>そういえば、カーニハン著のThe Go Programming Languageが11月発売とのこと</p>

<ul>
  <li><a href="http://www.amazon.co.jp/gp/product/0134190440">The Go Programming Language</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Goのjson.Marshal/Unmarshalの仕様を整理してみる]]></title>
    <link href="http://blog.restartr.com/2014/08/13/golang-json-marshal-unmarshal/"/>
    <updated>2014-08-13T00:02:42+09:00</updated>
    <id>http://blog.restartr.com/2014/08/13/golang-json-marshal-unmarshal</id>
    <content type="html"><![CDATA[<h3 id="tldr">TL;DR</h3>

<ul>
  <li>goの構造体につけるタグは、フォーマットが不正だと読み込まれない(当然)</li>
  <li>json.Marshalは、構造体のjsonタグがあればその値をキーとしてJSON文字列を生成する</li>
  <li>json.Unmarshalは、構造体のjsonタグがあればその値を対応するフィールドにマッピングする
    <ul>
      <li>jsonタグがなければ、完全一致もしくはcase-insensitiveなフィールドにマッピングする</li>
    </ul>
  </li>
</ul>

<p>では、ひとつづつ確認していきます。</p>

<h3 id="go">goの構造体につけるタグは、フォーマットが不正だと読み込まれない(当然)</h3>

<p>goの構造体にはタグの機能があって、型の後に特定のフォーマットでアノテーションが記述できます</p>

<p><code>go
type MyType struct {
  Hoge string `foo:"1" bar:"2"`
}
</code></p>

<p><code>key:"value"</code>をスペース区切りで複数かけます。
で、アクセスするにはリフレクションを使います。</p>

<p><code>go
t := reflect.TypeOf(MyType{})
tagFoo := t.Field(0).Get("foo")
tagBar := t.Field(0).Get("bar")
fmt.Printf("foo=%s, bar=%s\n", tagFoo, tagBar)
// foo=1, bar=2
</code></p>

<p>タグのフォーマットが不正な場合は、値が空になります。コンパイルエラーにはなりません。</p>

<p><code>go
type MyType struct {
  Hoge string `foo:1`
}
t := reflect.TypeOf(MyType{})
tagFoo := t.Field(0).Get("foo")
fmt.Printf("foo=%#v\n", tagFoo)
// foo=""
</code></p>

<p>このエラーをコンパイルする前に検知するには、<code>go vet</code>コマンドが使えます。</p>

<p><code>bash
$ go vet my_type.go
my_type.go:10: struct field tag `foo:1` not compatible with reflect.StructTag.Get
</code></p>

<p>できれば<code>go compile</code>実行したときに自動的にチェックしてほしいところですが…</p>

<p>で、jsonパッケージのMarshal/Unmarshalは、このタグを使ってアノテーションを記述することができます。</p>

<h3 id="jsonmarshaljsonjson">json.Marshalは、構造体のjsonタグがあればその値をキーとしてJSON文字列を生成する</h3>

<p>json.Marshalは構造体からJSON文字列への変換する関数です。</p>

<p>```go
type MyType struct {
  A string
  FooBar string
}</p>

<p>mt := MyType{“aaaa”, “baz”}
b, _ := json.Marshal(mt)
fmt.Printf(“%s\n”, string(b))
// {“A”:”aaaa”,”FooBar”:”baz”}
```</p>

<p>普通にやると、フィールド名がそのままJSONのキーになります。</p>

<p>ここで構造体のタグ機能をつかって、フィールド名のアノテーションを書くことで、任意のフィールド名でJSONが生成できます。</p>

<p>```go
type MyType struct {
  A string <code>json:"a"</code>
  FooBar string <code>json:"foo_bar"</code>
}</p>

<p>mt := MyType{“aaaa”, “baz”}
b, _ := json.Marshal(mt)
fmt.Printf(“%s\n”, string(b))
// {“a”:”aaaa”,”foo_bar”:”baz”}
```</p>

<p>アノテーション指定した”a”がJSONのキーとして使用されていることが確認できます。</p>

<h3 id="jsonunmarshaljson">json.Unmarshalは、構造体のjsonタグがあればその値を対応するフィールドにマッピングする</h3>

<p>json.UnmarshalはJSON文字列から構造体へ変換する関数です。</p>

<p>まずはタグなしのパターン</p>

<p>```
type MyType struct {
  A string
  FooBar string
}</p>

<p>var mt MyType
json.Unarshal([]byte(<code>{"A":"aaa", "FooBar":"baz"}</code>, &amp;mt)
fmt.Printf(“%#v\n”, mt) // main.MyType{A:”aaaa”,FooBar:”baz”}
```</p>

<p>JSONのフィールド名がsnake_caseのパターン</p>

<p><code>
var mt MyType
json.Unarshal([]byte(`{"a":"aaa","foo_bar":"baz"}`, &amp;mt)
fmt.Printf("%#v\n", mt) // main.MyType{A:"aaaa", FooBar:""}
</code></p>

<p>ここで「ん？」となるわけです。タグによるアノテーションがないのになぜ小文字のフィールドがちゃんと読み込まれているのか…と。</p>

<p>この仕様、json.Unmarshalのgodocにちゃんと書いてあります。</p>

<p><a href="http://golang.org/pkg/encoding/json/#Unmarshal">func Unmarshal</a></p>

<blockquote>
  <p>To unmarshal JSON into a struct, Unmarshal matches incoming object keys to the keys used by Marshal (either the struct field name or its tag), preferring an exact match but also accepting a case-insensitive match.</p>
</blockquote>

<p>どうやら、json.Unmarshalは、JSONに含まれるキーと完全一致か、case-insensitiveに一致する構造体のフィールドにマッピングする仕様となっているようです。もちろん、snake_caseなJSONのキーはアノテーションがないとマッピングされず無視されます。（構造体のフィールドとしてsnale_caseが存在しない限りは)</p>

<h3 id="section">経緯</h3>

<p>先日、<a href="http://connpass.com/event/7914/">ヒカルのGO! hikarie.go #2</a>で<a href="https://twitter.com/yosuke_furukawa">@yosuke_furukawa</a>さんによるGoでJSON APIを書いてみるというハンズオンを体験してきました。</p>

<ul>
  <li><a href="https://github.com/yosuke-furukawa/golang-study">yosuke-furukawa/golang-study</a></li>
</ul>

<p>そこで、アノテーションをつけた構造体を使ってMarshalした時に、書いたコードがこれです。</p>

<p><code>go
type User struct {
  Name string `json:name`
}
user := User{"restartr"}
b, _ := json.Marshal(user)
fmt.Printf("%s\n", string(b)) // {"Name":"restartr"}
</code></p>

<p>小文字で出力してほしいのに、アノテーションが効かない…となったわけです。
他の参加者が<code>json:"name"</code>でないといけないことに気づいて、この件は一件落着。</p>

<p>だったのですが、もう少し詳しく調べると上に整理したような仕様が見えてきたというわけです。</p>

<p><code>go
type User struct {
  Name string `json:name` // 実際は無視されている
}
var user User
json.Unmarshal([]byte(`{"name":"restartr"}`, &amp;user)
fmt.Printf("%s\n", user) // main.User{Name:"restartr"}
</code></p>

<p>実はこの時書いた<code>json:name</code>というアノテーションは不正なフォーマットとして無視されていて、たまたまUser.Nameというフィールドにcase-insensitiveでUnmarshalした時にマッピングができていたにすぎなかったようです。</p>

<p>とまぁそんな感じでJSONの取り扱いについて正しい知識を得られたのですが、一人でやってた時には気づかなかった疑問とか知識として不足している点に気付けるので、ハンズオン形式も良いものですね。</p>
]]></content>
  </entry>
  
</feed>

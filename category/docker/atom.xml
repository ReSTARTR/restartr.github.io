<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: docker | I Will Survive]]></title>
  <link href="http://blog.restartr.com/category/docker/atom.xml" rel="self"/>
  <link href="http://blog.restartr.com/"/>
  <updated>2015-10-21T20:19:17+09:00</updated>
  <id>http://blog.restartr.com/</id>
  <author>
    <name><![CDATA[ReSTARTR]]></name>
    <email><![CDATA[yoshida.masaki+restartr@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[DockerとWeaveを使って1台のマシンでConsulを複数動かしてみる]]></title>
    <link href="http://blog.restartr.com/2015/03/09/consul-cluster-with-docker/"/>
    <updated>2015-03-09T00:22:13+09:00</updated>
    <id>http://blog.restartr.com/2015/03/09/consul-cluster-with-docker</id>
    <content type="html"><![CDATA[<p>軽くConsulを試してみたくて、でもVagrantで複数台仮想マシンを立ち上げるのはちょっと気が重い…ということでUbuntu14.10 on MacBookAirにDockerコンテナを複数立ち上げてクラスタを構築してみるテストをしました。</p>

<p>Dockerfileとか簡単な動かし方(を適当英語で書いたもの)をgithubにあげてあります</p>

<ul>
  <li><a href="https://github.com/ReSTARTR/test-consul-with-docker">ReSTARTR/test-consul-with-docker</a></li>
</ul>

<p>Docker内のプロセスがLISTENするポートに対してコンテナ外から接続する場合、<code>-p</code>でホストのポートにひもづけるか、<code>--link</code>でコンテナ同士をつなぐのが最も手軽な方法です。が、consulは複数のポート（HTTP API用、DNS用、ゴシッププロトコル用等）を使うため、この手軽な方法でクラスタを構築することができません。</p>

<p>Dockerコンテナの接続パターンとしてはいくつかあって、deeeetさんのブログ記事に詳しく書かれています。</p>

<ul>
  <li><a href="http://deeeet.com/writing/2014/12/01/docker-link-pattern/">Dockerコンテナ接続パターン (2014年冬) | SOTA</a></li>
</ul>

<p>今回は手元のMacBook Airだけで完結させたかったので、weaveを使ったコンテナ間ネットワークを利用することにしました。</p>

<h3 id="weave">weave</h3>

<ul>
  <li><a href="http://zettio.github.io/weave/">weave  | weave, the Docker network</a></li>
</ul>

<p>dockerコンテナ間の内部ネットワークを構築するものです。詳しくはjacopenさんのSlideShareを。</p>

<ul>
  <li><a href="http://www.slideshare.net/jacopen/weave-40871981">Weaveを試してみた</a></li>
</ul>

<p>使い方はとても簡単で、weaveコンテナを立ち上げて、weaveコマンド経由でdockerコマンドを実行するだけ。
これならVagrantのような仮想マシンのためにメモリとディスク容量を割く必要もなくなります。</p>

<p><code>bash
$ sudo weave launch
$ sudo docker ps
CONTAINER ID        IMAGE                COMMAND                CREATED             STATUS              PORTS                                            NAMES
2eda921c011e        zettio/weave:0.9.0   "/home/weave/weaver    31 seconds ago      Up 30 seconds       0.0.0.0:6783-&gt;6783/tcp, 0.0.0.0:6783-&gt;6783/udp   weave
</code></p>

<p>これだけで仮想ネットワークができあがります。ホストOSで必要なポートは6783だけです。</p>

<p>あとはweaveコマンドにIPを指定しつつdockerコマンドのオプションを付けて起動すればOK。</p>

<p><code>bash
$ C=$(sudo weave run 10.0.0.1/24 -it ubuntu)
$ sudo docker exec $C -it /bin/bash
</code></p>

<p>ただ、さくらVPSのCentOS6では動きませんでした。面倒なので深く追ってません。。。</p>

<p><code>bash
$ sudo /usr/local/bin/weave launch
WARNING: Linux kernel version 3.5 or newer is required (you have 2.6)
ERROR: ip utility, iproute2-ss091226 does not support network namespaces.
       Please install iproute2-ss111010 or later.
</code></p>

<h3 id="consul">consul</h3>

<ul>
  <li><a href="https://www.consul.io/">consul</a></li>
</ul>

<p>Hashicorp謹製クラスタのオーケストレーションツール。今更説明する必要もないと思うので詳細は省略します。
consul（と周辺ツールのconsul-templateやenvconsul)を使えば複数のホスト間で設定を共有できる、というのを試すのが今回の目的でしたが、とりあえず複数のconsulを動かすところまでを書きます。</p>

<h3 id="consul-1">consulを起動してクラスタを構築する</h3>

<p>weaveネットワークに接続したコンテナを4台立ち上げて、consul1, consul2をserverとして、consul3, consul4をclientとして起動します。</p>

<p><code>bash
$ sudo weave run 10.0.0.1/24 -it -v $(pwd -P):/opt --name=consul1 restartr/consul-ready
$ sudo weave run 10.0.0.2/24 -it -v $(pwd -P):/opt --name=consul2 restartr/consul-ready
$ sudo weave run 10.0.0.3/24 -it -v $(pwd -P):/opt --name=consul3 restartr/consul-ready
$ sudo weave run 10.0.0.4/24 -it -v $(pwd -P):/opt --name=consul4 restartr/consul-ready
</code></p>

<p>あとはconsul agentを順に起動するだけ。</p>

<p>ここで注意するのが<code>-bind</code>オプション。
これを指定しないとdockerデフォルトのeth0のでクラスタにjoinすることになってしまい、このネットワークは他のコンテナとつながっていないためにクラスタ構築に失敗します。
必ず<code>weave run 10.0.0.X/24</code>で指定したIPにbindしておきましょう。</p>

<p><code>bash
$ sudo docker exec -d consul1 consul agent -server -data-dir=/tmp/consul -bootstrap-expect 1 -bind 10.0.0.1
$ sudo docker exec -d consul2 consul agent -server -data-dir=/tmp/consul -config-dir=/opt/consul.d/web.json -bind 10.0.0.2
$ sudo docker exec -d consul3 consul agent -data-dir=/tmp/consul -config-dir=/opt/consul.d/web.json -bind 10.0.0.3
$ sudo docker exec -d consul4 consul agent -data-dir=/tmp/consul -config-dir=/opt/consul.d/web.json -bind 10.0.0.4
</code></p>

<p>で、先に起動したconsul1に対して残りのコンテナ内のconsul agentをjoinさせていきます。</p>

<p><code>bash
$ sudo docker exec consul2 consul join 10.0.0.1
$ sudo docker exec consul3 consul join 10.0.0.1
$ sudo docker exec consul4 consul join 10.0.0.1
</code></p>

<p>と、<code>consul members</code>でjoinしている一覧が見えるようになります。</p>

<p><code>bash
$ sudo docker exec consul1 consul members
Node          Address        Status  Type    Build  Protocol
725dca3980ea  10.0.0.1:8301  alive   server  0.5.0  2
f82001d6a7b4  10.0.0.2:8301  alive   server  0.5.0  2
dcf304f77fdf  10.0.0.3:8301  alive   client  0.5.0  2
3be672bd18b1  10.0.0.4:8301  alive   client  0.5.0  2
</code></p>

<p>クラスタから離れるときは<code>consul leave</code>です。</p>

<p>```bash
$ sudo docker exec consul4 consul leave
Graceful leave complete</p>

<p>$ sudo docker exec consul1 consul members
Node          Address        Status  Type    Build  Protocol
dcf304f77fdf  10.0.0.3:8301  alive   client  0.5.0  2
3be672bd18b1  10.0.0.4:8301  left    client  0.5.0  2       # &lt;- Statusが’alive’から’left’に変わる
725dca3980ea  10.0.0.1:8301  alive   server  0.5.0  2
f82001d6a7b4  10.0.0.2:8301  alive   server  0.5.0  2
```</p>

<p>という感じで、複数のマシンをいじってる感じがまったくしないくらい<code>weave</code> &amp; <code>docker exec</code>は便利です。
weaveがプロダクション環境で使えるか、という点については未知ですが。</p>

<p>次回（があれば）consulを使った設定の管理について試したメモを書きたいと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dockerを使って任意のrubyバージョンのrpmを作成する]]></title>
    <link href="http://blog.restartr.com/2014/05/11/build-rpm-on-docker-container/"/>
    <updated>2014-05-11T00:00:00+09:00</updated>
    <id>http://blog.restartr.com/2014/05/11/build-rpm-on-docker-container</id>
    <content type="html"><![CDATA[<p>CentOSを使ってて不便なのがruby2系のインストール。</p>

<p>rbenvやruby-buildを使うかソースからインストールするのですが、この場合、環境を構築するたびにビルドすることになり時間もかかるし大変面倒です。</p>

<p>なのでDockerを使ってクリーンな環境でRubyの最新rpmをビルドしてみました。</p>

<p>Dockerを使えばビルド環境がすぐに立ち上げられるので、rpmビルドに必要なパッケージを確認したりするのに最適です。</p>

<p>今回のソースはgithubにpushしてあります。</p>

<ul>
  <li><a href="https://github.com/ReSTARTR/ruby-rpmbuild-container">ReSTARTR/ruby-rpmbuild-container</a></li>
</ul>

<h2 id="section">環境</h2>

<ul>
  <li>ゲストOS：Vagrantで起動したUbuntu-14.04</li>
  <li>コンテナ：centos:6.4</li>
</ul>

<h2 id="section-1">ファイルの配置</h2>

<p>以下ファイルを同一ディレクトリに入れておきます。</p>

<ul>
  <li>Vagrantfile</li>
  <li>provision.sh</li>
  <li>Dockerfile</li>
  <li>rubybuild.sh</li>
  <li>ruby-2.0.0-p481.spec</li>
</ul>

<h2 id="section-2">手順</h2>

<ol>
  <li>ゲストOSの起動(Vagrant)</li>
  <li>ゲストOSにsshログイン</li>
  <li>Dockerコンテナのビルド</li>
  <li>Dockerコンテナ内でrpmビルド</li>
</ol>

<h2 id="os">1. ゲストOSの起動</h2>

<p>Vagrantfile</p>

<p>```ruby
# -<em>- mode: ruby -</em>-
# vi: set ft=ruby :
VAGRANTFILE_API_VERSION = “2”</p>

<p>Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  config.vm.box = “ubuntu/trusty64”</p>

<p>config.vm.synced_folder “.”, “/vagrant”</p>

<p>config.vm.provision “shell”, path: ‘provision.sh’</p>

<p># お好みで
  config.vm.provider :virtualbox do |vb|
    vb.customize [“modifyvm”, :id, “–memory”, “2048”, “–cpus”, “2”, “–ioapic”, “on”]
  end
end
```</p>

<p>provision.sh</p>

<p>```bash
sudo apt-get update
sudo apt-get install -y language-pack-ja</p>

<h1 id="docker">Docker</h1>
<p>sudo apt-get install -y docker.io
sudo ln -sf /usr/bin/docker.io /usr/local/bin/docker
```</p>

<h2 id="osssh">2. ゲストOSにsshログイン</h2>

<p><code>bash
$ vagrant up
$ vagrant ssh
$ cd /vagrant
</code></p>

<h2 id="docker-1">3. Dockerコンテナのビルド</h2>

<p>ビルド用specファイルを用意して、シェルスクリプトでビルドします。</p>

<p>すると、コンテナにマウントしたボリュームにビルド済みのrpmファイルがコピーされます。</p>

<h3 id="spec">ビルド用specシェルスクリプト</h3>

<p>環境変数RUBY_VERSIONに”2.0.0-p481”や”2.0.0-p451”を設定すれば任意のバージョンをビルドします。</p>

<p><em>※デフォルトの2.0.0-p481以外はそれ用のspecファイルが必要になります。</em></p>

<p>rubybuild.sh</p>

<p>```bash
#!/bin/env bash
WORKDIR=/opt/rpmbuild</p>

<p>RUBY_VER=${RUBY_VER:-“2.0.0-p481”}
RUBY_MAJOUR_VER=$(echo $RUBY_VER|cut -d”-“ -f1)
RUBY_MINOR_VER=$(echo $RUBY_VER|cut -d”-“ -f2)
if [ -z “$RUBY_MINOR_VER” ]; then
  RUBY_TARBALL=”ruby-$RUBY_MAJOUR_VER.tar.gz”
else
  RUBY_TARBALL=”ruby-$RUBY_MAJOUR_VER-$RUBY_MINOR_VER.tar.gz”
fi
RUBY_REMOTE_FILE=”http://cache.ruby-lang.org/pub/ruby/${RUBY_MAJOUR_VER:0:3}/$RUBY_TARBALL”</p>

<p>mkdir -p $WORKDIR/rpm/{BUILD,SRPMS,SPECS,SOURCES,RPMS}
echo “%_topdir $WORKDIR/rpm” &gt; $WORKDIR/.rpmmacros
if [ ! -f $WORKDIR/rpm/SOURCES/$RUBY_TARBALL ]; then
  wget $RUBY_REMOTE_FILE -O $WORKDIR/rpm/SOURCES/$RUBY_TARBALL
fi
cp $WORKDIR/ruby-${RUBY_VER}.spec $WORKDIR/rpm/SPECS/ruby.spec
rpmbuild -bb $WORKDIR/rpm/SPECS/ruby.spec</p>

<p>cp $WORKDIR/rpm/RPMS/x86_64/* /shared/
```</p>

<h2 id="dockerrpm">4. Dockerコンテナ内でrpmビルド</h2>

<p>Dockerfile</p>

<p>```
FROM centos:6.4</p>

<h1 id="setup">setup</h1>
<p>RUN yum update -y
RUN yum install -y rpm-build gcc</p>

<h1 id="epel">epel</h1>
<p>RUN rpm –import http://dl.fedoraproject.org/pub/epel/RPM-GPG-KEY-EPEL-6
RUN rpm -ihv http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</p>

<h1 id="ruby-depends">ruby-depends</h1>
<p>RUN yum install —enablerepo=epel -y libyaml-devel
RUN yum install -y byacc readline-devel ncourses-devel tcl-devel openssl-devel gdbm-devel db4-devel</p>

<h1 id="build-rpm">build rpm</h1>
<p>WORKDIR /opt/rpmbuild
ADD rubybuild.sh /opt/rpmbuild/rubybuild.sh
ADD ruby-2.0.0-p481.spec /opt/rpmbuild/ruby-2.0.0-p481.spec
```</p>

<h2 id="rpm">コンテナ起動してrpmをビルド</h2>

<p>コンテナを起動する際に、カレントディレクトリをマウントしておきます。</p>

<p><em>※<code>--rm</code>オプションでrpm作成完了したらコンテナは破棄します</em></p>

<p><code>bash
$ sudo docker build -t &lt;USERNAME&gt;/rpmbuild .
$ sudo docker run --rm -v $PWD:/shared:rw -it &lt;CONTAINER_ID&gt; /bin/sh ./rubybuild.sh
</code></p>

<p>成功すれば、ゲストOSのカレントディレクトリにrpmができてます。</p>

<p><code>
$ ls *.rpm
ruby-2.0.0p481-2.el6.x86_64.rpm
</code></p>

<p>これで、rpmコマンド一発で最新のrubyをインストールできます。</p>

<p>rubyインストール済みコンテナを作るなら、Dockerfileに以下のように書けばruby実行環境のできあがりです。</p>

<p>```
FROM centos:6.4</p>

<h1 id="epel-1">EPEL</h1>
<p>RUN rpm –import http://dl.fedoraproject.org/pub/epel/RPM-GPG-KEY-EPEL-6
RUN rpm -ihv http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</p>

<h1 id="install-ruby-rpm">Install ruby rpm</h1>
<p>ADD ruby-2.0.0p481-2.el6.x86<em>64.rpm ruby-2.0.0p481-2.el6.x86</em>64.rpm
RUN yum install -y –enablerepo=epel libyaml-devel
RUN rpm -ihv ruby-2.0.0p481-2.el6.x86_64.rpm
```</p>
]]></content>
  </entry>
  
</feed>
